<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">var MEI2VF = ( function(m2v, VF, $, undefined) {

<span id='MEI2VF-Measure-method-constructor'><span id='MEI2VF-Measure'>    /**
</span></span>     * @class MEI2VF.Measure
     * @private
     *
     * @constructor
     */
    m2v.Measure = function(config) {
      this.init(config);
    };

    m2v.Measure.prototype = {

      // currently fixed
      HALF_LINE_DISTANCE : 5, // VF.Staff.spacing_between_lines_px / 2;

      init : function(config) {
        var me = this;
<span id='MEI2VF-Measure-cfg-element'>        /**
</span>         * @cfg {XMLElement} element the MEI element of the current measure
         */
        me.element = config.element;
<span id='MEI2VF-Measure-cfg-n'>        /**
</span>         * @cfg {Number} n The number of the current measure as specified in
         * the MEI document
         */
        me.n = config.n;
        // TODO instead of passing the staff contents in the config object, use a method addToMeasure!?!
<span id='MEI2VF-Measure-cfg-staffs'>        /**
</span>         * @cfg {Array} staffs an array of the staffs in the current
         * measure. Contains
         */
        me.staffs = config.staffs;
<span id='MEI2VF-Measure-cfg-voices'>        /**
</span>         * @cfg {MEI2VF.StaveVoices} voices The voices of all staffs in the
         * current measure
         */
        me.voices = config.voices;
<span id='MEI2VF-Measure-cfg-startConnectors'>        /**
</span>         * @cfg {MEI2VF.Connectors} startConnectors an instance of
         * MEI2VF.Connectors handling all left connectors (only the first measure
         * in a system has data)
         */
        me.startConnectors = new m2v.Connectors(config.startConnectorCfg);
<span id='MEI2VF-Measure-cfg-startConnectors'>        /**
</span>         * @cfg {MEI2VF.Connectors} startConnectors an instance of
         * MEI2VF.Connectors handling all right connectors
         */
        me.inlineConnectors = new m2v.Connectors(config.inlineConnectorCfg);
<span id='MEI2VF-Measure-cfg-tempoElements'>        /**
</span>         * @cfg {Array} tempoElements the MEI tempo elements in the current
         * measure
         */
        me.tempoElements = config.tempoElements;
<span id='MEI2VF-Measure-cfg-the'>        /**
</span>         * @cfg {Object} the font used for rendering tempo specifications
         */
        me.tempoFont = config.tempoFont;
<span id='MEI2VF-Measure-property-the'>        /**
</span>         * @property {Number} the maximum note_start_x value of all
         * Vex.Flow.Stave objects in the current measure
         */
        me.maxNoteStartX = 0;
<span id='MEI2VF-Measure-property-meiW'>        /**
</span>         * @property {Number} meiW the width attribute of the measure element or
         * null if NaN
         */
        me.meiW = me.readMEIW(me.element);
      },

<span id='MEI2VF-Measure-method-readMEIW'>      /**
</span>       *  reads the width attribute of the specified element and converts it to a
       * number
       * @param {XMLElement} element the element to process
       * @return {Number} the number of the attribute or null if NaN
       */
      readMEIW : function(element) {
        return +element.getAttribute('width') || null;
      },

<span id='MEI2VF-Measure-method-getStaffs'>      /**
</span>       * gets the staffs array of the current measure
       * @return {Array}
       */
      getStaffs : function() {
        return this.staffs;
      },

<span id='MEI2VF-Measure-method-getVoices'>      /**
</span>       * gets the voices object of the current measure
       * @return {MEI2VF.StaveVoices}
       */
      getVoices : function() {
        return this.voices;
      },

<span id='MEI2VF-Measure-method-getX'>      /**
</span>       * gets the x coordinate of the staff
       * @return {Number}
       */
      getX : function() {
        return this.getFirstDefinedStaff().x;
      },

<span id='MEI2VF-Measure-method-getN'>      /**
</span>       * gets the number of the current staff as specified in the MEI code
       * @return {Number}
       */
      getN : function() {
        return this.n;
      },

<span id='MEI2VF-Measure-method-getFirstDefinedStaff'>      /**
</span>       * gets the first defined staff in the current measure
       * @return {Vex.Flow.Stave}
       */
      getFirstDefinedStaff : function() {
        var me = this, i, j;
        for ( i = 0, j = me.staffs.length; i &lt; j; i += 1) {
          if (me.staffs[i]) {
            return me.staffs[i];
          }
        }
        throw new m2v.RUNTIME_ERROR('ERROR', 'getFirstDefinedStaff(): no staff found in the current measure.');
      },

      // TODO handle timestamps! (is it necessary to handle tempo element
      // as annotations?)
      // TODO make magic numbers constants
<span id='MEI2VF-Measure-method-addTempoToStaves'>      /**
</span>       * Writes the data of the tempo elements in the current measure to the
       * corresponding Vex.Flow.Stave object
       */
      addTempoToStaves : function() {
        var me = this, offsetX, vexStaff, vexTempo, atts;
        $.each(me.tempoElements, function() {
          atts = m2v.Util.attsToObj(this);
          vexStaff = me.staffs[atts.staff];
          vexTempo = new Vex.Flow.StaveTempo({
            name : $(this).text(),
            duration : atts['mm.unit'],
            dots : +atts['mm.dots'],
            bpm : +atts.mm
          }, vexStaff.x, 5);
          if (atts.vo)
            vexTempo.setShiftY(+atts.vo * me.HALF_LINE_DISTANCE);
          offsetX = (vexStaff.getModifierXShift() &gt; 0) ? -14 : 14;
          if ( typeof vexStaff.timeSigIndex === 'number')
            offsetX -= 24;
          if (atts.ho)
            offsetX += +atts.ho * me.HALF_LINE_DISTANCE;
          vexTempo.setShiftX(offsetX);
          vexTempo.font = me.tempoFont;
          vexStaff.modifiers.push(vexTempo);
        });
      },

<span id='MEI2VF-Measure-method-calculateMinWidth'>      /**
</span>       * calculates the minimum width of the current measure
       */
      calculateMinWidth : function() {
        var me = this;
        me.calculateMaxNoteStartX();
        me.calculateRepeatPadding();
        me.minVoicesW = me.voices.preFormat();
        me.minWidth = me.maxNoteStartX + me.minVoicesW + me.repeatPadding; 
      },
      
<span id='MEI2VF-Measure-method-getMinWidth'>      /**
</span>       * gets the minimum width of the current measure; 
       */
      getMinWidth: function() {
        return this.minWidth;
      },

<span id='MEI2VF-Measure-method-calculateMaxNoteStartX'>      /**
</span>       * calculates the maximum note_start_x of all Vex.Flow.Stave objects in the
       * current measure
       */
      calculateMaxNoteStartX : function() {
        var me = this, i, staffs, staff;
        staffs = me.staffs;
        i = staffs.length;
        while (i--) {
          staff = staffs[i];
          if (staff) {
            me.maxNoteStartX = Math.max(me.maxNoteStartX, staff.getNoteStartX());
          }
        }
      },

<span id='MEI2VF-Measure-method-calculateRepeatPadding'>      /**
</span>       * calculates additional start padding when there are repetition start bars
       * in the current measure
       */
      calculateRepeatPadding : function() {
        var me = this;
        var staff = me.getFirstDefinedStaff();
        me.repeatPadding = (staff.modifiers[0].barline == Vex.Flow.Barline.type.REPEAT_BEGIN &amp;&amp; staff.modifiers.length &gt; 2) ? 20 : 0;
      },

      // TODO align start modifiers (changes in vexflow necessary??)
      
      // TODO move label attachment somewhere else
<span id='MEI2VF-Measure-method-format'>      /**
</span>       * Formats the staffs in the current measure: sets x coordinates and adds
       * staff labels
       * @param {Number} x The x coordinate of the the measure
       * @param {Object} labels
       */
      format : function(x, labels) {
        var me = this, width = me.w, i = me.staffs.length;
        while (i--) {
          if (me.staffs[i]) {
            staff = me.staffs[i];
            if (labels &amp;&amp; typeof labels[i] === 'string') {
              staff.setText(labels[i], VF.Modifier.Position.LEFT, {
                shift_y : -3
              });
            }
            staff.x += x;
            staff.glyph_start_x += x;
            staff.start_x = staff.x + me.maxNoteStartX;
            staff.bounds.x += x;
            staff.setWidth(width);
            staff.modifiers[0].x += x;
            // staff.end_x += x + offsetW;
            // staff.glyph_end_x += x + offsetW;
          }
        }
      },

<span id='MEI2VF-Measure-method-draw'>      /**
</span>       * Draws the staffs, voices and connectors in the current measure to a
       * canvas
       * @param {Object} ctx the canvas context
       */
      draw : function(ctx) {
        var me = this, i, staffs, staff;
        staffs = me.staffs;
        i = staffs.length;
        while (i--) {
          staff = staffs[i];
          if (staff) {
            staff.setContext(ctx).draw();
          }
        }
        me.voices.format(me.getFirstDefinedStaff());
        me.voices.draw(ctx, staffs);
        me.startConnectors.setContext(ctx).draw();
        me.inlineConnectors.setContext(ctx).draw();
      }
    };

    return m2v;

  }(MEI2VF || {}, Vex.Flow, jQuery));
</pre>
</body>
</html>
