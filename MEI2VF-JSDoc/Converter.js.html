<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: Converter.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: Converter.js</h1>

    


    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/*
 * MEItoVexFlow
 *
 * Author: Richard Lewis Contributors: Zoltan Komives, Raffaele Viglianti
 *
 * See README for details of this library
 *
 * Copyright Â© 2012, 2013 Richard Lewis, Raffaele Viglianti, Zoltan Komives,
 * University of Maryland
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

var MEI2VF = ( function(m2v, VF, $, undefined) {

    /**
     * Converts an MEI XML document / document fragment to VexFlow objects and
     * optionally renders it using Raphael or HTML5 Canvas.
     *
     * Usage:
     *
     * - Either pass a config object to the constructor function or (if no config
     * object has been passed) call {@link #initConfig} after construction.
     * - Call {@link #process} to process an MEI XML document
     * - Call {@link #draw} to draw the processed VexFlow objects to a canvas

     * @class MEI2VF.Converter
     *
     * @constructor
     * @param {Object} [config]
     * @chainable
     * @return {MEI2VF.Converter} this
     */
    m2v.Converter = function(config) {
      if (config)
        this.initConfig(config);
      return this;
    };

    m2v.Converter.prototype = {

      // TODO calculate now, that should not be too expensive
      // currently fixed
      HALF_LINE_DISTANCE : 5, // VF.Staff.spacing_between_lines_px / 2;

      BOTTOM : VF.Annotation.VerticalJustify.BOTTOM,

      defaults : {
        /**
         * @cfg {Number} page_width The width of the page
         */
        page_width : 800,
        /**
         * @cfg {Number} page_margin_top The top page margin
         */
        page_margin_top : 60,
        /**
         * @cfg {Number} page_margin_left The left page margin
         */
        page_margin_left : 20,
        /**
         * @cfg {Number} page_margin_right The right page margin
         */
        page_margin_right : 20,
        /**
         * @cfg {Number} systemSpacing The spacing between two staff
         * systems
         */
        systemSpacing : 90,
        /**
         * @cfg {Number} staveSpacing The default spacing between two staffs
         * within a system; overridden by the spacing attribute of a staffDef
         * element in the MEI code
         */
        staveSpacing : 60,
        /**
         * @cfg {Boolean} autoStaveConnectorLine Specifies if a stave connector
         * line is drawn on the left of systems by default; if set to true, the
         * auto line will not appear when staffDef/@symbol="none" is set for the
         * outermost staffDef element
         */
        autoStaveConnectorLine : true,
        /**
         * @cfg {"full"/"abbr"/null} labelMode Specifies the way voice labels are
         * added
         * to staves. Values:
         *
         * - 'full': renders full labels in the first system, abbreviated labels
         * in all following systems
         * - 'abbr': only render abbreviated labels
         * - null or undefined: renders no labels
         */
        labelMode : null, // 'full',
        /**
         * @cfg {Number} maxHyphenDistance The maximum distance (in pixels)
         * between two hyphens in the lyrics lines
         */
        maxHyphenDistance : 75,
        //sectionsOnNewLine : false, // TODO: add feature

        // TODO check compatibility with RAPHAEL!
        /**
         * @cfg {Object} lyricsFont The font used for rendering lyrics (and
         * hyphens)
         * @cfg {String} lyricsFont.family the font family
         * @cfg {Number} lyricsFont.size the font size
         *
         * NB the weight properties can be used to specify style, weight
         * or both (space separated); some of the objects are passed directly
         * to vexFlow (which requires the name 'weight'), so the name is
         * 'weight'
         */
        lyricsFont : {
          family : 'Times',
          size : 15
        },
        /**
         * @cfg {Object} annotFont the font used for annotations (for example,
         * 'pizz.')
         * @cfg {String} annotFont.family the font family
         * @cfg {Number} annotFont.size the font size
         * @cfg {String} annotFont.weight the font weight
         */
        annotFont : {
          family : 'Times',
          size : 15,
          weight : 'Italic'
        },
        /**
         * @cfg {Object} dynamFont the font used for dynamics
         * @cfg {String} dynamFont.family the font family
         * @cfg {Number} dynamFont.size the font size
         * @cfg {String} dynamFont.weight the font weight
         */
        dynamFont : {
          family : 'Times',
          size : 18,
          weight : 'bold italic'
        },
        /**
         * @cfg {Object} tempoFont The tempo font
         * @cfg {String} tempoFont.family the font family
         * @cfg {Number} tempoFont.size the font size
         * @cfg {String} tempoFont.weight the font weight
         */
        tempoFont : {
          family : "Times",
          size : 17,
          weight : "bold"
        },
        /**
         * @cfg {Object} staff The staff config object passed to each
         * Vex.Flow.Staff
         */
        staff : {
          vertical_bar_width : 20, // 10 // Width around vertical bar end-marker
          top_text_position : 1.5, // 1 // in staff lines
          bottom_text_position : 7.5
        }
      },

      // TODO add setters (and getters?) for single config items / groups
      /**
       * initializes the Converter
       * @method initConfig
       * @param {Object} config A config object (optional)
       * @chainable
       * @return {MEI2VF.Converter} this
       */
      initConfig : function(config) {
        var me = this;
        me.cfg = $.extend(true, {}, me.defaults, config);
        /**
         * an instance of MEI2VF.SystemInfo dealing with the system and staff
         * info derived from
         * the MEI data
         * @property {MEI2VF.SystemInfo} systemInfo
         */
        me.systemInfo = new m2v.SystemInfo();

        // TODO see if the values of this property should better be calculated
        // in the viewer object
        /**
         * The print space coordinates calculated from the page config.
         * @property {Object} printSpace
         * @property {Number} printSpace.top
         * @property {Number} printSpace.left
         * @property {Number} printSpace.right
         * @property {Number} printSpace.width
         */
        me.printSpace = {
          // substract four line distances (40px) from page_margin_top in order
          // to compensate VexFlow's default top spacing / allow specifying
          // absolute
          // values
          top : me.cfg.page_margin_top - 40,
          left : me.cfg.page_margin_left,
          right : me.cfg.page_width - me.cfg.page_margin_right,
          width : Math.floor(me.cfg.page_width - me.cfg.page_margin_right - me.cfg.page_margin_left) - 1
        };
        return me;

      },

      // TODO instead of creating new objects each time on reset, call reset functions in the generated objects
      /**
       * Resets all data. Called by {@link #process}.
       * @method reset
       * @chainable
       * @return {MEI2VF.Converter} this
       */
      reset : function() {
        var me = this;
        me.systemInfo.init(me.cfg, me.printSpace);
        /**
         * @property {} unresolvedTStamp2
         */
        me.unresolvedTStamp2 = [];
        /**
         * Contains all {@link MEI2VF.System} objects
         * @property {MEI2VF.System[]} systems
         */

        me.systems = [];
        /**
         * Contains all
         * Vex.Flow.Stave objects. Addressing scheme:
         * [measure_n][staff_n]
         * @property {Vex.Flow.Stave[][]} allVexMeasureStaffs
         */
        me.allVexMeasureStaffs = [];
        /**
         * Contains all Vex.Flow.Beam objects. Data is just pushed in
         * and later processed as a whole, so the array index is
         * irrelevant.
         * @property {Vex.Flow.Beam[]} allBeams
         */
        me.allBeams = [];
        /**
         * an instance of MEI2VF.Dynamics dealing with and storing all dynamics
         * found in the MEI document
         * @property {MEI2VF.Dynamics} dynamics
         */
        me.dynamics = new m2v.Dynamics(me.systemInfo, me.cfg.dynamFont);
        /**
         * an instance of MEI2VF.Directives dealing with and storing all
         * directives found in the MEI document
         * @property {MEI2VF.Directives} directives
         */
        me.directives = new m2v.Directives(me.systemInfo, me.cfg.annotFont);
        /**
         * an instance of MEI2VF.Ties dealing with and storing all ties found in
         * the MEI document
         * @property {MEI2VF.Ties} ties
         */
        me.ties = new m2v.Ties(me.systemInfo, me.unresolvedTStamp2);
        /**
         * an instance of MEI2VF.Ties dealing with and storing all slurs found in
         * the MEI document
         * @property {MEI2VF.Ties} slurs
         */
        me.slurs = new m2v.Ties(me.systemInfo, me.unresolvedTStamp2);
        /**
         * an instance of MEI2VF.Hairpins dealing with and storing all hairpins
         * found in the MEI document
         * @property {MEI2VF.Hairpins} hairpins
         */
        me.hairpins = new m2v.Hairpins(me.systemInfo, me.unresolvedTStamp2);
        /**
         * an instance of MEI2VF.Hyphenation dealing with and storing all lyrics
         * hyphens found in the MEI document
         * @property {MEI2VF.Hyphenation} hyphenation
         */
        me.hyphenation = new m2v.Hyphenation(me.cfg.lyricsFont, me.printSpace.right, me.cfg.maxHyphenDistance);
        /**
         * contains all note-like objects in the current MEI document, accessible
         * by their xml:id
         * @property {Object} notes_by_id
         * @property {XMLElement} notes_by_id.meiNote the XML Element of the note
         * @property {Vex.Flow.StaveNote} notes_by_id.vexNote the VexFlow note
         * object
         */
        me.notes_by_id = {};
        /**
         * the number of the current system
         * @property {Number} currentSystem_n
         */
        me.currentSystem_n = 0;
        /**
         * indicates if a system break is currently to be processed
         * @property {Boolean} pendingSystemBreak
         */
        me.pendingSystemBreak = false;
        /**
         * indicates if a system break is currently to be processed
         * @property {Boolean} pendingSectionBreak
         */
        me.pendingSectionBreak = true;
        /**
         * Contains information about the
         * volta type of the current staff. Properties:
         *
         * -  `start` {String} indicates the number to render to the volta. When
         * falsy, it is assumed that the volta does not start in the current
         * measure
         * -  `end` {Boolean} indicates if there is a volta end in the current
         * measure
         *
         * If null, no volta is rendered
         * @property {Object} currentVoltaType
         */
        me.currentVoltaType = null;
        return me;
      },

      /**
       * Calls {@link #reset} and then processes the specified MEI document or
       * document fragment. The generated objects can
       * be processed further or drawn immediately to a canvas via {@link #draw}.
       * @method process
       * @chainable
       * @param {XMLDocument} xmlDoc the XML document
       * @return {MEI2VF.Converter} this
       */
      process : function(xmlDoc) {
        var me = this;
        me.reset();
        me.systemInfo.processScoreDef($(xmlDoc).find('scoreDef')[0]);
        me.processSections(xmlDoc);
        me.directives.createVexFromInfos(me.notes_by_id);
        me.dynamics.createVexFromInfos(me.notes_by_id);
        me.ties.createVexFromInfos(me.notes_by_id);
        me.slurs.createVexFromInfos(me.notes_by_id);
        me.hairpins.createVexFromInfos(me.notes_by_id);
        return me;
      },

      /**
       * Draws the internal data objects to a canvas
       * @method draw
       * @chainable
       * @param ctx The canvas context
       * @return {MEI2VF.Converter} this
       */
      draw : function(ctx) {
        var me = this;
        me.drawSystems(ctx);
        me.drawVexBeams(me.allBeams, ctx);
        me.ties.setContext(ctx).draw();
        me.slurs.setContext(ctx).draw();
        me.hairpins.setContext(ctx).draw();
        me.hyphenation.setContext(ctx).draw();
        return me;
      },

      /**
       * assigns an external function for processing pgHead elements. By default,
       * pgHead elements are ignored in MEI2VF.
       * @method setPgHeadProcessor
       * @param {Function} fn the callback function. Parameter: element
       */
      setPgHeadProcessor : function(fn) {
        this.systemInfo.processPgHead = fn;
      },

      /**
       * assigns an external function for processing anchoredText elements. By
       * default, anchoredText elements are ignored in MEI2VF.
       * @method setAnchoredTextProcessor
       * @param {Function} fn the callback function. Parameter: element
       */
      setAnchoredTextProcessor : function(staffFn, layerFn) {
        if (staffFn) {
          this.processAnchoredStaffText = staffFn;
        };
        if (layerFn) {
          this.processAnchoredLayerText = layerFn;
        }
      },

      /**
       * Returns the width and the height of the area that contains all drawn
       * staves as per the last processing.
       *
       * @method getStaffArea
       * @return {Object} the width and height of the area that contains all
       * staves.
       * Properties: width, height
       */
      getStaffArea : function() {
        var width, height, i;
        height = this.systemInfo.getCurrentLowestY();
        var allVexMeasureStaffs = this.getAllVexMeasureStaffs();
        var i, k, max_start_x, area_width, staff;
        i = allVexMeasureStaffs.length;
        area_width = 0;
        while (i--) {
          if (allVexMeasureStaffs[i]) {
            max_start_x = 0;
            // get maximum start_x of all staffs in measure
            k = allVexMeasureStaffs[i].length;
            while (k--) {
              staff = allVexMeasureStaffs[i][k];
              if (staff)
                max_start_x = Math.max(max_start_x, staff.getNoteStartX());
            }
            k = allVexMeasureStaffs[i].length;
            while (k--) {
              // get maximum width of all staffs in measure
              staff = allVexMeasureStaffs[i][k];
              if (staff) {
                area_width = Math.max(area_width, max_start_x + staff.getWidth());
              }
            }
          }
        }
        return {
          width : area_width,
          height : height
        };
      },

      /**
       * returns a 2d array of all Vex.Flow.Stave objects, arranged by
       * [measure_n][staff_n]
       * @method getAllVexMeasureStaffs
       * @return {Vex.Flow.Stave[][]} see {@link #allVexMeasureStaffs}
       */
      getAllVexMeasureStaffs : function() {
        return this.allVexMeasureStaffs;
      },

      /**
       * returns all systems created when processing the MEI document
       * @method getSystems
       * @return {MEI2VF.System[]}
       */
      getSystems : function() {
        return this.systems;
      },

      /**
       * returns all note-like objects created when processing the MEI document
       * @method getNotes
       * @return {Object} for the object properties, see {@link #notes_by_id}
       */
      getNotes : function() {
        return this.notes_by_id;
      },

      /**
       * creates in initializes a new {@link MEI2VF.System} and updates the staff
       * modifier infos
       * @method createNewSystem
       */
      createNewSystem : function() {
        var me = this, system, coords;

        m2v.L('Converter.createNewSystem()', '{enter}');

        me.pendingSystemBreak = false;
        me.currentSystem_n += 1;

        coords = {
          x : me.printSpace.left,
          y : (me.currentSystem_n === 1) ? me.printSpace.top : me.systemInfo.getCurrentLowestY() + me.cfg.systemSpacing,
          w : me.printSpace.width
        };

        system = new m2v.System({
          leftMar : me.systemInfo.getLeftMar(),
          coords : coords,
          staffYs : me.systemInfo.getYs(coords.y),
          labels : me.getStaffLabels()
        });

        if (me.pendingSectionBreak) {
          me.pendingSectionBreak = false;
          me.systemInfo.forceSectionStartInfos();
        } else {
          me.systemInfo.forceStaveStartInfos();
        }

        me.hyphenation.addLineBreaks(me.systemInfo.getAllStaffInfos(), {
          system : system
        });

        me.systems[me.currentSystem_n] = system;
        return system;
      },

      // TODO: add rule: if an ending is followed by another ending, add
      // space on the right (or choose a VexFlow parameter accordingly),
      // otherwise don't add space
      /**
       * @method processSections
       */
      processSections : function(xmlDoc) {
        var me = this;
        $(xmlDoc).find('section, ending').each(function() {
          if (this.localName === 'ending') {
            me.processEnding(this);
          } else {
            me.processSection(this);
          }
        });
      },

      /**
       *@method processSection
       */
      processSection : function(element) {
        var me = this, i, j, sectionChildren = $(element).children();
        for ( i = 0, j = sectionChildren.length; i &lt; j; i += 1) {
          me.processSectionChild(sectionChildren[i]);
        }
      },

      /**
       * @method processEnding
       */
      processEnding : function(element) {
        var me = this, i, j, sectionChildren = $(element).children();
        for ( i = 0, j = sectionChildren.length; i &lt; j; i += 1) {
          me.currentVoltaType = {};
          if (i === 0)
            me.currentVoltaType.start = $(element).attr('n');
          if (i === j - 1)
            me.currentVoltaType.end = true;
          me.processSectionChild(sectionChildren[i]);
        }
        me.currentVoltaType = null;
      },

      /**
       * MEI element &lt;b>section&lt;/b> may contain (MEI v2.1.0): MEI.cmn: measure
       * MEI.critapp: app MEI.edittrans: add choice corr damage del gap
       * handShift orig reg restore sic subst supplied unclear MEI.shared:
       * annot ending expansion pb sb scoreDef section staff staffDef
       * MEI.text: div MEI.usersymbols: anchoredText curve line symbol
       *
       * Supported elements: &lt;b>measure&lt;/b> &lt;b>scoreDef&lt;/b> &lt;b>staffDef&lt;/b>
       * &lt;b>sb&lt;/b>
       *  @method processSectionChild
       */
      processSectionChild : function(element) {
        var me = this;
        switch (element.localName) {
          case 'measure' :
            me.processMeasure(element);
            break;
          case 'scoreDef' :
            me.systemInfo.processScoreDef(element);
            break;
          case 'staffDef' :
            me.systemInfo.processStaffDef(element);
            break;
          case 'sb' :
            me.setPendingSystemBreak(element);
            break;
          default :
            throw new m2v.RUNTIME_ERROR('MEI2VF.RERR.NotSupported', 'Element &lt;' + element.localName + '> is not supported in &lt;section>');
        }
      },

      /**
       * sets the property {@link #pendingSystemBreak} to `true`. When true, a
       * new system will be initialized when {@link #processMeasure} is called
       * the next time.
       *  @method setPendingSystemBreak
       */
      setPendingSystemBreak : function() {
        this.pendingSystemBreak = true;
      },

      // TODO extract function for measure_child (see the staffDef functions)!?
      /**
       * Processes a MEI measure element and calls functions to process a
       * selection of ancestors: .//staff, ./slur, ./tie, ./hairpin, .//tempo
       *  @method processMeasure
       * @param {XMLElement} element the MEI measure element
       */
      processMeasure : function(element) {
        var me = this, measure_n, atSystemStart, left_barline, right_barline, atSystemTop = true, system, system_n;

        if (me.pendingSectionBreak || me.pendingSystemBreak) {
          system_n = me.systems.length;
          system = me.createNewSystem();
          atSystemStart = true;
        } else {
          system_n = me.systems.length - 1;
          system = me.systems[system_n];
          atSystemStart = false;
        }

        m2v.L('Converter.processMeasure()', '{enter}');

        measure_n = +element.getAttribute('n');
        left_barline = element.getAttribute('left');
        right_barline = element.getAttribute('right');

        var staffElements = [], dirElements = [], slurElements = [], tieElements = [], hairpinElements = [], tempoElements = [], dynamElements = [];

        $(element).find('*').each(function() {
          switch (this.localName) {
            case 'staff':
              staffElements.push(this);
              break;
            case 'dir':
              dirElements.push(this);
              break;
            case 'tie':
              tieElements.push(this);
              break;
            case 'slur':
              slurElements.push(this);
              break;
            case 'hairpin':
              hairpinElements.push(this);
              break;
            case 'tempo':
              tempoElements.push(this);
              break;
            case 'dynam':
              dynamElements.push(this);
              break;
            default:
              break;
          }
        });

        // references to the staffs will be stored in two places:
        // 1) in the measure objects
        // 2) in this.allVexMeasureStaffs
        var staffs = [];
        me.allVexMeasureStaffs[measure_n] = staffs;

        var currentStaveVoices = new m2v.StaveVoices();

        // TODO create all staff objects before processing the voices so a
        // reference to any staff object in the current measure can be set to the
        // note-like objects (this is necessary when the attribute staff=n is
        // used, for example)
        $.each(staffElements, function() {
          me.processStaffInMeasure(system, staffs, this, measure_n, left_barline, right_barline, currentStaveVoices, atSystemTop);
          atSystemTop = false;
        });

        me.directives.createInfos(dirElements, element);
        me.dynamics.createInfos(dynamElements, element);
        me.ties.createInfos(tieElements, element, me.systemInfo);
        me.slurs.createInfos(slurElements, element, me.systemInfo);
        me.hairpins.createInfos(hairpinElements, element, me.systemInfo);

        system.addMeasure(new m2v.Measure({
          element : element,
          n : measure_n,
          staffs : staffs,
          voices : currentStaveVoices,
          startConnectorCfg : (atSystemStart) ? {
            labelMode : me.cfg.labelMode,
            models : me.systemInfo.startConnectorInfos,
            staffs : staffs,
            system_n : me.currentSystem_n
          } : null,
          inlineConnectorCfg : {
            models : me.systemInfo.inlineConnectorInfos,
            staffs : staffs,
            barline_l : left_barline,
            barline_r : right_barline
          },
          tempoElements : tempoElements,
          tempoFont : me.cfg.tempoFont
        }));
      },

      /**
       * Processes a single stave in a measure
       *
       * @method processStaffInMeasure
       * @param {MEI2VF.System} system the current system
       * @param {Array} staffs
       * @param {XMLElement} staff_element the MEI staff element
       * @param {Number} measure_n the measure number
       * @param {String} left_barline the left barline
       * @param {String} right_barline the right barline
       * @param {MEI2VF.StaveVoices} currentStaveVoices The current MEI2VF
       * StaveVoices object
       * @param {Boolean} atSystemTop indicates if the current stave is the first
       * stave in its system
       */
      processStaffInMeasure : function(system, staffs, staff_element, measure_n, left_barline, right_barline, currentStaveVoices, atSystemTop) {
        var me = this, staff, staff_n, readEvents, layer_events;

        staff_n = +$(staff_element).attr('n');
        if (!staff_n) {
          throw new m2v.RUNTIME_ERROR('MEI2VF.RERR.BadArgument', 'Cannot render staff without attribute "n".');
        }

        staff = me.createVexStaff(system.getStaffYs()[staff_n]);

        me.addStaffModifiers(staff, staff_n, left_barline, right_barline, atSystemTop);

        staffs[staff_n] = staff;

        $(staff_element).children('anchoredText').each(function() {
          me.processAnchoredStaffText(this, staff);
        });

        readEvents = function() {
          var event = me.processNoteLikeElement(this, staff, staff_n);
          // return event.vexNote;
          return event.vexNote || event;
        };

        $(staff_element).find('layer').each(function() {
          me.resolveUnresolvedTimestamps(this, staff_n, measure_n);
          layer_events = $(this).children().map(readEvents).get();
          currentStaveVoices.addVoice(me.createVexVoice(layer_events, staff_n), staff_n);
        });

      },

      /**
       * Creates a new Vex.Flow.Stave object at the specified y coordinate. This
       * method sets fixed x coordinates, which will later be substituted in
       * {@link MEI2VF.System#format} - the Vex.Flow.Stave
       * objects must be initialized with some x measurements, but the real
       * values depend on values only available after modifiers, voices etc
       * have been added.
       *
       *  @method createVexStaff
       * @param {Number} y the y coordinate of the staff
       * @return {Vex.Flow.Stave} The initialized stave object
       */
      createVexStaff : function(y) {
        var me = this, staff;
        staff = new VF.Stave();
        staff.init(0, y, 1000, me.cfg.staff);
        // temporary; (due to a bug?) in VexFlow, bottom_text_position does
        // not work when it's passed in the config object
        staff.options.bottom_text_position = me.cfg.staff.bottom_text_position;
        return staff;
      },

      /**
       * Adds staff modifiers (bar lines, clef, time signature, key signature,
       * volta) to a Vex.Flow.Staff.
       *
       *  @method addStaffModifiers
       * @param {Vex.Flow.Stave} staff The stave object
       * @param {Number} staff_n the staff number
       * @param {String} left_barline the left barline
       * @param {String} right_barline the right barline
       * @param {Boolean} atSystemTop indicates if the current stave is the first
       * stave in its system
       */
      addStaffModifiers : function(staff, staff_n, left_barline, right_barline, atSystemTop) {
        var me = this, currentStaffInfo;

        currentStaffInfo = me.systemInfo.getStaffInfo(staff_n);

        if (currentStaffInfo.showClefCheck()) {
          staff.clefIndex = 2;
          staff.addClef(currentStaffInfo.getClef());
        }
        if (currentStaffInfo.showKeysigCheck()) {
          staff.keySigIndex = staff.clefIndex + 1 || 2;
          staff.addKeySignature(currentStaffInfo.getKeySpec());

        }
        if (currentStaffInfo.showTimesigCheck()) {
          staff.timeSigIndex = staff.keySigIndex + 1 || staff.clefIndex + 1 || 2;
          staff.addTimeSignature(currentStaffInfo.getTimeSig());
        }

        staff.setBegBarType( left_barline ? m2v.tables.barlines[left_barline] : VF.Barline.type.NONE);
        if (right_barline)
          staff.setEndBarType(m2v.tables.barlines[right_barline]);

        if (atSystemTop &amp;&amp; me.currentVoltaType) {
          me.addStaffVolta(staff);
        }
      },

      /**
       * Adds a volta to a staff. Currently not working due to the reworking of
       * the measure width calulation (27/4/2014)
       *  @method addStaffVolta
       * @experimental
       */
      addStaffVolta : function(staff) {
        var volta = this.currentVoltaType;
        if (volta.start)
          staff.setVoltaType(Vex.Flow.Volta.type.BEGIN, volta.start + '.', 30, 0);
        if (volta.end)
          staff.setVoltaType(Vex.Flow.Volta.type.END, "", 30, 0);
        if (!volta.start &amp;&amp; !volta.end)
          staff.setVoltaType(Vex.Flow.Volta.type.MID, "", 30, 0);
      },

      /**
       * @method getStaffLabels
       */
      getStaffLabels : function() {
        var me = this, labels, i, infos, labelType;
        labels = {};
        if (!me.cfg.labelMode) {
          return labels;
        }
        labelType = (me.cfg.labelMode === 'full' &amp;&amp; me.currentSystem_n === 1) ? 'label' : 'labelAbbr';
        infos = me.systemInfo.getAllStaffInfos();
        i = infos.length;
        while (i--) {
          if (infos[i]) {
            labels[i] = infos[i][labelType];
          }
        }
        return labels;
      },

      /**
       * Creates a new Vex.Flow.Voice
       *  @method createVexVoice
       * @param {Array} voice_contents The contents of the voice, an array of
       * tickables
       * @param {Number} staff_n The number of the enclosing staff element
       * return {Vex.Flow.Voice}
       */
      createVexVoice : function(voice_contents, staff_n) {
        var me = this, voice, meter;
        if (!$.isArray(voice_contents)) {
          throw new m2v.RUNTIME_ERROR('BadArguments', 'me.createVexVoice() voice_contents argument must be an array.');
        }
        meter = me.systemInfo.getStaffInfo(staff_n).meter;
        voice = new VF.Voice({
          num_beats : meter.count,
          beat_value : meter.unit,
          resolution : VF.RESOLUTION
        });
        voice.setStrict(false);
        voice.addTickables(voice_contents);
        return voice;
      },

      /**
       * @method resolveUnresolvedTimestamps
       */
      resolveUnresolvedTimestamps : function(layer, staff_n, measure_n) {
        var me = this, refLocationIndex;
        // check if there's an unresolved TStamp2 reference to this location
        // (measure, staff, layer):
        if (isNaN(measure_n))
          throw new m2v.RUNTIME_ERROR('MEI2VF.RERR.extract_events', '&lt;measure> must have @n specified');
        staff_n = staff_n || 1;
        refLocationIndex = measure_n + ':' + staff_n + ':' + ($(layer).attr('n') || '1');
        if (me.unresolvedTStamp2[refLocationIndex]) {
          $(me.unresolvedTStamp2[refLocationIndex]).each(function(i) {
            this.setContext({
              layer : layer,
              meter : me.systemInfo.getStaffInfo(staff_n).meter
            });
            // TODO: remove eventLink from the list
            me.unresolvedTStamp2[refLocationIndex][i] = null;
          });
          // at this point all references should be supplied with context.
          me.unresolvedTStamp2[refLocationIndex] = null;
        }
      },

      /**
       * processes a note like element by calling the adequate processing
       * function
       *  @method processNoteLikeElement
       * @param {XMLElement} element the element to process
       * @param {} staff
       * @param {Number} staff_n the number of the staff as given in the MEI
       * document
       */
      processNoteLikeElement : function(element, staff, staff_n) {
        var me = this;
        switch (element.localName) {
          case 'rest' :
            return me.processRest(element, staff, staff_n);
          case 'mRest' :
            return me.processmRest(element, staff, staff_n);
          case 'space' :
            return me.processSpace(element, staff, staff_n);
          case 'note' :
            return me.processNote(element, staff, staff_n);
          case 'beam' :
            return me.processBeam(element, staff, staff_n);
          case 'chord' :
            return me.processChord(element, staff, staff_n);
          case 'anchoredText' :
            return me.processAnchoredLayerText(element, staff, staff_n);
          default :
            throw new m2v.RUNTIME_ERROR('BadArguments', 'Rendering of element "' + element.localName + '" is not supported.');
        }
      },

      /**
       * @method processAnchoredStaffText
       */
      processAnchoredStaffText : function() {
        // override
        return;
      },

      /**
       * @method processAnchoredLayerText
       */
      processAnchoredLayerText : function() {
        // TODO
        return;
      },

      /**
       * @method processNote
       */
      processNote : function(element, staff, staff_n) {
        var me = this, dots, mei_accid, mei_ho, pname, oct, xml_id, mei_tie, mei_slur, mei_staff_n, i, atts, note_opts, note;

        atts = m2v.Util.attsToObj(element);

        dots = +atts.dots;
        mei_accid = atts.accid;
        mei_ho = atts.ho;
        pname = atts.pname;
        oct = atts.oct;
        mei_tie = atts.tie;
        mei_slur = atts.slur;
        mei_staff_n = +atts.staff || staff_n;

        xml_id = atts['xml:id'];
        // If xml:id is missing, create it
        if (!xml_id) {
          xml_id = MeiLib.createPseudoUUID();
          $(element).attr('xml:id', xml_id);
        }

        try {

          note_opts = {
            keys : [me.processAttsPitch(element)],
            clef : me.systemInfo.getClef(staff_n),
            duration : me.processAttsDuration(element)
          };

          me.setStemDir(element, note_opts);
          note = new VF.StaveNote(note_opts);

          if (mei_staff_n === staff_n) {
            note.setStave(staff);
          } else {
            var otherStaff = me.allVexMeasureStaffs[me.allVexMeasureStaffs.length - 1][mei_staff_n];
            if (otherStaff) {
              // TODO: the note is correctly assigned to the new staff
              // here, but
              // in the end it has the old staff assigned to it -> fix
              // that!
              // REASON PROBABLY: all notes get assigned to the old
              // staff when
              // the voices are drawn in StaveVoices.js
              // ALSO: Vex.Flow.Voice seems to assign all voice
              // tickables to only
              // one staff
              // n = note;
              note.setStave(otherStaff);
            } else {
              throw new m2v.RUNTIME_ERROR('Error', 'Note has staff attribute "' + mei_staff_n + '", but the staff does not exist.');
            }
          }

          me.processSyllables(note, element, staff_n);

          try {
            for ( i = 0; i &lt; dots; i += 1) {
              note.addDotToAll();
            }
          } catch (e) {
            throw new m2v.RUNTIME_ERROR('BadArguments', 'A problem occurred processing the dots of &lt;note>: ' + m2v.Util.attsToString(element));
          }

          if (mei_accid)
            me.processAttrAccid(mei_accid, note, 0);
          if (mei_ho)
            me.processAttrHo(mei_ho, note);

          $.each($(element).find('artic'), function() {
            me.addArticulation(note, this);
          });
          if (atts.fermata) {
            me.addFermata(note, atts.fermata);
          }

          // FIXME For now, we'll remove any child nodes of &lt;note>
          $.each($(element).children(), function() {
            $(this).remove();
          });

          // Build a note object that keeps the xml:id

          if (!pname)
            throw new m2v.RUNTIME_ERROR('MEI2VF.RERR.BadArguments', 'mei:note must have pname attribute');
          if (!oct)
            throw new m2v.RUNTIME_ERROR('MEI2VF.RERR.BadArguments', 'mei:note must have oct attribute');

          if (mei_tie)
            me.processAttrTie(mei_tie, xml_id, pname, oct);
          if (mei_slur)
            me.processAttrSlur(mei_slur, xml_id);

          me.notes_by_id[xml_id] = {
            meiNote : element,
            vexNote : note,
            system : me.currentSystem_n
          };

          // return note object
          return {
            vexNote : note,
            id : xml_id
          };

        } catch (e1) {
          throw new m2v.RUNTIME_ERROR('BadArguments', 'A problem occurred processing the &lt;note>: ' + m2v.Util.attsToString(element) + '\nORIGINAL ERROR MESSAGE: ' + e1.toString());
        }
      },

      // TODO add support for features found in me.processNote (annot etc.)
      // extract functions!?
      /**
       * @method processChord
       */
      processChord : function(element, staff, staff_n) {
        var me = this, i, j, hasDots, $children, keys = [], duration, durations = [], durAtt, xml_id, mei_slur, mei_ho, chord, chord_opts, atts, note_atts;

        $children = $(element).children();

        atts = m2v.Util.attsToObj(element);
        durAtt = atts.dur;
        // mei_tie = atts.tie;
        // mei_slur = atts.slur;

        xml_id = atts['xml:id'];
        // If xml:id is missing, create it
        if (!xml_id) {
          xml_id = MeiLib.createPseudoUUID();
          $(element).attr('xml:id', xml_id);
        }

        hasDots = !!$(element).attr('dots');

        try {
          if (durAtt) {
            duration = me.translateDuration(+durAtt);
          } else {
            for ( i = 0, j = $children.length; i &lt; j; i += 1) {
              durations.push(+$children[i].getAttribute('dur'));
            }
            duration = me.translateDuration(Math.max.apply(Math, durations));
          }

          for ( i = 0, j = $children.length; i &lt; j; i += 1) {
            keys.push(me.processAttsPitch($children[i]));
            // dots.push(+$children[i].getAttribute('dots'));
            if ($children[i].getAttribute('dots') === '1')
              hasDots = true;
          }

          if (hasDots)
            duration += 'd';

          chord_opts = {
            keys : keys,
            clef : me.systemInfo.getClef(staff_n),
            duration : duration
          };

          me.setStemDir(element, chord_opts);
          chord = new VF.StaveNote(chord_opts);
          chord.setStave(staff);

          var allNoteIndices = [];

          $children.each(function(i) {
            me.processNoteInChord(i, this, element, chord);
            allNoteIndices.push(i);
          });

          if (hasDots) {
            chord.addDotToAll();
          }
          if (atts.ho) {
            me.processAttrHo(atts.ho, chord);
          }
          if (atts.fermata) {
            me.addFermata(chord, atts.fermata);
          }

          // TODO add support for chord/@tie and chord/@slur

          me.notes_by_id[xml_id] = {
            meiNote : element,
            vexNote : chord,
            index : allNoteIndices,
            system : me.currentSystem_n
          };

          return {
            vexNote : chord,
            id : xml_id
          };
        } catch (e) {
          throw new m2v.RUNTIME_ERROR('BadArguments', 'A problem occurred processing the &lt;chord>:' + e.toString());
          // 'A problem occurred processing the &lt;chord>: ' +
          // JSON.stringify($.each($(element).children(), function(i,
          // element) {
          // element.attrs();
          // }).get()) + '. \"' + x.toString() + '"');
        }
      },

      /**
       * @method processNoteInChord
       */
      processNoteInChord : function(i, element, chordElement, chord) {
        var me = this, atts, xml_id;

        atts = m2v.Util.attsToObj(element);

        var xml_id = atts['xml:id'];
        // If xml:id is missing, create it
        if (!xml_id) {
          xml_id = MeiLib.createPseudoUUID();
          $(element).attr('xml:id', xml_id);
        }

        if (atts.tie)
          me.processAttrTie(atts.tie, xml_id, atts.pname, atts.oct);
        if (atts.slur)
          me.processAttrSlur(atts.slur, xml_id);

        me.notes_by_id[xml_id] = {
          meiNote : chordElement,
          vexNote : chord,
          index : [i],
          system : me.currentSystem_n
        };

        if (atts.accid) {
          me.processAttrAccid(atts.accid, chord, i);
        }
        if (atts.fermata) {
          me.addFermata(chord, atts.fermata, i);
        }
      },

      /**
       * @method processRest
       */
      processRest : function(element, staff, unused_staff_n) {
        var me = this, dur, rest, xml_id, atts;
        try {
          atts = m2v.Util.attsToObj(element);

          dur = me.processAttsDuration(element, true);
          // assign whole rests to the fourth line, all others to the
          // middle line:
          rest = new VF.StaveNote({
            keys : [(dur === 'w') ? 'd/5' : 'b/4'],
            duration : dur + 'r'
          });

          xml_id = atts['xml:id'];

          // If xml:id is missing, create it
          if (!xml_id) {
            xml_id = MeiLib.createPseudoUUID();
            $(element).attr('xml:id', xml_id);
          }

          if (atts.ho) {
            me.processAttrHo(atts.ho, rest);
          }
          rest.setStave(staff);
          if (atts.dots === '1') {
            rest.addDotToAll();
          }
          if (atts.fermata) {
            me.addFermata(rest, atts.fermata);
          }
          me.notes_by_id[xml_id] = {
            meiNote : element,
            vexNote : rest,
            system : me.currentSystem_n
          };
          return {
            vexNote : rest,
            id : xml_id
          };
        } catch (e) {
          throw new m2v.RUNTIME_ERROR('BadArguments', 'A problem occurred processing the &lt;rest>: ' + m2v.Util.attsToString(element));
        }
      },

      /**
       * @method processmRest
       */
      processmRest : function(element, staff) {
        var me = this, mRest, atts, xml_id;

        try {
          atts = m2v.Util.attsToObj(element);

          mRest = new VF.StaveNote({
            keys : ['d/5'],
            duration : 'wr'
          });

          xml_id = atts['xml:id'];

          // If xml:id is missing, create it
          if (!xml_id) {
            xml_id = MeiLib.createPseudoUUID();
            $(element).attr('xml:id', xml_id);
          }

          // mRest.ignore_ticks = true;
          // mRest.addToModifierContext = function() {
          // return this;
          // };
          // console.log(mRest);
          // me.processAttrHo(10, mRest);

          if (atts.ho) {
            me.processAttrHo(atts.ho, mRest);
          }
          if (atts.fermata) {
            me.addFermata(mRest, atts.fermata);
          }
          mRest.setStave(staff);
          me.notes_by_id[xml_id] = {
            meiNote : element,
            vexNote : mRest,
            system : me.currentSystem_n
          };
          return {
            vexNote : mRest,
            id : xml_id
          };
        } catch (x) {
          throw new m2v.RUNTIME_ERROR('BadArguments', 'A problem occurred processing the &lt;mRest>: ' + m2v.Util.attsToString(element));
        }
      },

      /**
       * @method processSpace
       */
      processSpace : function(element, staff) {
        var me = this, space;
        try {
          space = new VF.GhostNote({
            duration : me.processAttsDuration(element, true) + 'r'
          });
          // space.setStave(staff);
          // me.notes_by_id[xml_id] = {
          // meiNote : element,
          // vexNote : space
          // };
          return {
            vexNote : space
            // ,
            // id : xml_id
          };
        } catch (e) {
          throw new m2v.RUNTIME_ERROR('BadArguments', 'A problem occurred processing the &lt;space>: ' + m2v.Util.attsToString(element));
        }
      },

      /**
       * @method processBeam
       */
      processBeam : function(element, staff, staff_n) {
        var me = this, elements;
        var process = function() {
          // make sure to get vexNote out of wrapped note objects
          var proc_element = me.processNoteLikeElement(this, staff, staff_n);
          return proc_element.vexNote || proc_element;
        };
        elements = $(element).children().map(process).get();
        me.allBeams.push(new VF.Beam(elements));
        return elements;
      },

      /**
       * @method processAttrAccid
       */
      processAttrAccid : function(mei_accid, vexObject, i) {
        var val = m2v.tables.accidentals[mei_accid];
        if (!val) {
          throw new m2v.RUNTIME_ERROR('MEI2VF.RERR.BadAttributeValue', 'Invalid attribute value: ' + mei_accid);
        }
        vexObject.addAccidental(i, new VF.Accidental(val));
      },

      /**
       * @method processAttrHo
       */
      processAttrHo : function(mei_ho, vexObject) {
        var me = this;
        vexObject.setExtraLeftPx(+mei_ho * me.HALF_LINE_DISTANCE);
      },

      /**
       * @method processAttrTie
       */
      processAttrTie : function(mei_tie, xml_id, pname, oct) {
        var me = this, i, j;
        // if (!mei_tie) {
        // mei_tie = "";
        // }
        for ( i = 0, j = mei_tie.length; i &lt; j; ++i) {
          if (mei_tie[i] === 'i') {
            me.ties.start_tieslur(xml_id, {
              pname : pname,
              oct : oct
              //,system : system
            });
          } else if (mei_tie[i] === 't') {
            me.ties.terminate_tie(xml_id, {
              pname : pname,
              oct : oct
              //,system : system
            });
          }
        }
      },

      /**
       * @method processAttrSlur
       */
      processAttrSlur : function(mei_slur, xml_id) {
        var me = this, tokens;
        if (mei_slur) {
          // create a list of { letter, num }
          tokens = me.parse_slur_attribute(mei_slur);
          $.each(tokens, function() {
            if (this.letter === 'i') {
              me.slurs.start_tieslur(xml_id, {
                nesting_level : this.nesting_level
                //,system : system
              });
            } else if (this.letter === 't') {
              me.slurs.terminate_slur(xml_id, {
                nesting_level : this.nesting_level
                //,system : system
              });
            }
          });
        }
      },

      /**
       * @method parse_slure_attribute
       */
      parse_slur_attribute : function(slur_str) {
        var result = [], numbered_tokens, numbered_token, i, j, num;
        numbered_tokens = slur_str.split(' ');
        for ( i = 0, j = numbered_tokens.length; i &lt; j; i += 1) {
          numbered_token = numbered_tokens[i];
          if (numbered_token.length === 1) {
            result.push({
              letter : numbered_token,
              nesting_level : 0
            });
          } else if (numbered_token.length === 2) {
            num = +numbered_token[1];
            if (!num) {
              throw new m2v.RUNTIME_ERROR('MEI2VF.RERR.BadArguments:ParseSlur01', "badly formed slur attribute");
            }
            result.push({
              letter : numbered_token[0],
              nesting_level : num
            });
          } else {
            throw new m2v.RUNTIME_ERROR('MEI2VF.RERR.BadArguments:ParseSlur01', "badly formed slur attribute");
          }
        }
        return result;
      },

      /**
       * converts the pitch of an MEI &lt;b>note&lt;/b> element to a VexFlow pitch
       *
       *  @method processAttsPitch
       * @param {XMLElement} mei_note
       * @return {String} the VexFlow pitch
       */
      processAttsPitch : function(mei_note) {
        var pname, oct;
        pname = $(mei_note).attr('pname');
        oct = $(mei_note).attr('oct');
        if (!pname || !oct) {
          throw new m2v.RUNTIME_ERROR('MEI2VF.RERR.MissingAttribute', 'pname and oct attributes must be specified for &lt;note>');
        }
        return pname + '/' + oct;
      },

      /**
       * adds an articulation to a note-like object
       *  @method addArticulation
       * @param {Vex.Flow.StaveNote} note the note-like VexFlow object
       * @param {XMLElement} ar the articulation element
       */
      addArticulation : function(note, ar) {
        var vexArtic = new VF.Articulation(m2v.tables.articulations[ar.getAttribute('artic')]);
        var place = ar.getAttribute('place');
        if (place) {
          vexArtic.setPosition(m2v.tables.positions[place]);
        }
        note.addArticulation(0, vexArtic);
      },

      /**
       * adds a fermata to a note-like object
       *  @method addFermata
       * @param {Vex.Flow.StaveNote} note the note-like VexFlow object
       * @param {'above'/'below'} place The place of the fermata
       * @param {Number} index The index of the note in a chord (optional)
       */
      addFermata : function(note, place, index) {
        var vexArtic = new VF.Articulation(m2v.tables.fermata[place]);
        vexArtic.setPosition(m2v.tables.positions[place]);
        note.addArticulation(index || 0, vexArtic);
      },

      /**
       * @method processSyllables
       */
      processSyllables : function(note, element, staff_n) {
        var me = this, annot, syl;
        syl = me.processSyllable(element);
        if (syl) {
          annot = me.createAnnot(syl.text, me.cfg.lyricsFont).setVerticalJustification(me.BOTTOM);
          // TODO handle justification
          // .setJustification(VF.Annotation.Justify.LEFT);
          note.addAnnotation(0, annot);
          if (syl.wordpos) {
            me.hyphenation.addSyllable(annot, syl.wordpos, staff_n);
          }
        }
      },

      // Add annotation (lyrics)
      // processSyllable : function(mei_note) {
      // var me = this, syl, full_syl = '', dash;
      // syl = $(mei_note).find('syl');
      // $(syl).each(function(i, s) {
      // dash = ($(s).attr('wordpos') === 'i' || $(s).attr('wordpos') === 'm')
      // ?
      // '-' : '';
      // full_syl += (i > 0 ? '\n' : '') + $(s).text() + dash;
      // });
      // return full_syl;
      // },

      // temporarily only handle one syllable per note
      /**
       * @method processSyllable
       */
      processSyllable : function(mei_note) {
        var syl = $(mei_note).find('syl')[0];
        if (syl) {
          return {
            text : $(syl).text(),
            wordpos : $(syl).attr('wordpos')
          };
        }
      },

      // Support for annotations
      /**
       * @method createAnnot
       */
      createAnnot : function(text, annotFont) {
        return (new VF.Annotation(text)).setFont(annotFont.family, annotFont.size, annotFont.weight);
      },

      /**
       * @method getMandatoryAttr
       */
      getMandatoryAttr : function(element, attribute) {
        var result = $(element).attr(attribute);
        if (!result) {
          throw new m2v.RUNTIME_ERROR('MEI2VF.RERR.MissingAttribute', 'Attribute ' + attribute + ' is mandatory.');
        }
        return result;
      },

      /**
       * @method translateDuration
       */
      translateDuration : function(mei_dur) {
        var result = m2v.tables.durations[mei_dur + ''];
        if (result)
          return result;
        throw new m2v.RUNTIME_ERROR('BadArguments', 'The MEI duration "' + mei_dur + '" is not supported.');
      },

      // TODO: dots should work with the lastest VexFlow, so try to remove the noDots
      // parameter there. Can the noDots condition be removed entirely or will there
      // be dots rendered with space elements?
      /**
       * @method processAttsDuration
       */
      processAttsDuration : function(mei_note, noDots) {
        var me = this, dur, dur_attr;

        dur_attr = $(mei_note).attr('dur');
        if (dur_attr === undefined) {
          alert('Could not get duration from:\n' + JSON.stringify(mei_note, null, '\t'));
        }
        dur = me.translateDuration(dur_attr);
        if (!noDots &amp;&amp; $(mei_note).attr('dots') === '1')
          dur += 'd';
        return dur;
      },

      /**
       * @method setStemDir
       */
      setStemDir : function(element, optionsObj) {
        var specified_dir = {
        down : VF.StaveNote.STEM_DOWN,
        up : VF.StaveNote.STEM_UP
        }[$(element).attr('stem.dir')];
        if (specified_dir) {
          optionsObj.stem_direction = specified_dir;
        } else {
          optionsObj.auto_stem = true;
        }
      },

      /**
       * @method drawSystems
       */
      drawSystems : function(ctx) {
        var me = this, i = me.systems.length;
        while (i--) {
          if (me.systems[i]) {
            me.systems[i].format(ctx).draw(ctx);
          }
        }
      },

      /**
       * @method drawVexBeams
       */
      drawVexBeams : function(beams, ctx) {
        $.each(beams, function() {
          this.setContext(ctx).draw();
        });

      }
    };

    return m2v;

  }(MEI2VF || {}, Vex.Flow, jQuery));
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Classes</h3><ul><li><a href="m2v.Converter.html">Converter</a></li><li><a href="MEI2VF.html">MEI2VF</a></li><li><a href="MeiLib.html">MeiLib</a></li><li><a href="MeiLib.Alt.html">Alt</a></li><li><a href="MeiLib.EventEnumerator.html">EventEnumerator</a></li><li><a href="MeiLib.MeiDoc.html">MeiDoc</a></li><li><a href="MeiLib.RuntimeError.html">RuntimeError</a></li><li><a href="MeiLib.Variant.html">Variant</a></li><li><a href="Vex.Flow.Hyphen.html">Hyphen</a></li><li><a href="Vex.Flow.StaveTie.html">StaveTie</a></li></ul><h3>Global</h3><ul><li><a href="global.html#addArticulation">addArticulation</a></li><li><a href="global.html#addFermata">addFermata</a></li><li><a href="global.html#addStaffModifiers">addStaffModifiers</a></li><li><a href="global.html#addStaffVolta">addStaffVolta</a></li><li></li><li><a href="global.html#createAnnot">createAnnot</a></li><li><a href="global.html#createNewSystem">createNewSystem</a></li><li><a href="global.html#createPseudoUUID">createPseudoUUID</a></li><li><a href="global.html#createVexStaff">createVexStaff</a></li><li><a href="global.html#createVexVoice">createVexVoice</a></li><li></li><li><a href="global.html#draw">draw</a></li><li><a href="global.html#drawSystems">drawSystems</a></li><li><a href="global.html#drawVexBeams">drawVexBeams</a></li><li></li><li></li><li><a href="global.html#getAllVexMeasureStaffs">getAllVexMeasureStaffs</a></li><li><a href="global.html#getALTs">getALTs</a></li><li><a href="global.html#getEditorList">getEditorList</a></li><li><a href="global.html#getMandatoryAttr">getMandatoryAttr</a></li><li><a href="global.html#getNotes">getNotes</a></li><li><a href="global.html#getPlainScore">getPlainScore</a></li><li><a href="global.html#getRichScore">getRichScore</a></li><li><a href="global.html#getRichSliceGet a slice of the whole rich MEI document.">getRichSliceGet a slice of the whole rich MEI document.</a></li><li><a href="global.html#getSectionViewSliceGet a slice of the sectionview_score.">getSectionViewSliceGet a slice of the sectionview_score.</a></li><li><a href="global.html#getSourceList">getSourceList</a></li><li><a href="global.html#getStaffArea">getStaffArea</a></li><li><a href="global.html#getStaffLabels">getStaffLabels</a></li><li><a href="global.html#getSystems">getSystems</a></li><li></li><li><a href="global.html#init">init</a></li><li></li><li><a href="global.html#initAltgroups">initAltgroups</a></li><li><a href="global.html#initConfig">initConfig</a></li><li></li><li><a href="global.html#nextEvent">nextEvent</a></li><li><a href="global.html#parse_slure_attribute">parse_slure_attribute</a></li><li></li><li><a href="global.html#parseEditorList">parseEditorList</a></li><li><a href="global.html#parseSourceListExtracts information about the sources as defined in the MEI header.">parseSourceListExtracts information about the sources as defined in the MEI header.</a></li><li><a href="global.html#process">process</a></li><li><a href="global.html#processAnchoredLayerText">processAnchoredLayerText</a></li><li><a href="global.html#processAnchoredStaffText">processAnchoredStaffText</a></li><li><a href="global.html#processAttrAccid">processAttrAccid</a></li><li><a href="global.html#processAttrHo">processAttrHo</a></li><li><a href="global.html#processAttrSlur">processAttrSlur</a></li><li><a href="global.html#processAttrTie">processAttrTie</a></li><li><a href="global.html#processAttsDuration">processAttsDuration</a></li><li><a href="global.html#processAttsPitch">processAttsPitch</a></li><li><a href="global.html#processBeam">processBeam</a></li><li><a href="global.html#processChord">processChord</a></li><li><a href="global.html#processEnding">processEnding</a></li><li><a href="global.html#processMeasure">processMeasure</a></li><li><a href="global.html#processmRest">processmRest</a></li><li><a href="global.html#processNote">processNote</a></li><li><a href="global.html#processNoteInChord">processNoteInChord</a></li><li><a href="global.html#processNoteLikeElement">processNoteLikeElement</a></li><li><a href="global.html#processRest">processRest</a></li><li><a href="global.html#processSection">processSection</a></li><li><a href="global.html#processSectionChild">processSectionChild</a></li><li><a href="global.html#processSections">processSections</a></li><li><a href="global.html#processSpace">processSpace</a></li><li><a href="global.html#processStaffInMeasure">processStaffInMeasure</a></li><li><a href="global.html#processSyllable">processSyllable</a></li><li><a href="global.html#processSyllables">processSyllables</a></li><li><a href="global.html#read_ahead">read_ahead</a></li><li><a href="global.html#replaceAltInstanceReplace an alternative instance in the sectionview score and in thesectionplane">replaceAltInstanceReplace an alternative instance in the sectionview score and in thesectionplane</a></li><li><a href="global.html#reset">reset</a></li><li><a href="global.html#resolveUnresolvedTimestamps">resolveUnresolvedTimestamps</a></li><li><a href="global.html#setAnchoredTextProcessor">setAnchoredTextProcessor</a></li><li><a href="global.html#setLogging enables or disables MEI2VF logging">setLogging enables or disables MEI2VF logging</a></li><li><a href="global.html#setPendingSystemBreak">setPendingSystemBreak</a></li><li><a href="global.html#setPgHeadProcessor">setPgHeadProcessor</a></li><li><a href="global.html#setStemDir">setStemDir</a></li><li></li><li><a href="global.html#step_ahead">step_ahead</a></li><li></li><li><a href="global.html#toString">toString</a></li><li><a href="global.html#translateDuration">translateDuration</a></li><li><a href="global.html#tstamp2idFind the event with the minimum distance from of the given timestamp.">tstamp2idFind the event with the minimum distance from of the given timestamp.</a></li><li></li><li><a href="global.html#XMLIDreturns the xml:id attribute of an element; if there is none, the functioncreated a pseudo id, adds it to the element and returns that id.">XMLIDreturns the xml:id attribute of an element; if there is none, the functioncreated a pseudo id, adds it to the element and returns that id.</a></li></ul>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0-alpha5</a> on Sat May 10 2014 06:02:53 GMT+0200 (MitteleuropÃ¤ische Sommerzeit)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
