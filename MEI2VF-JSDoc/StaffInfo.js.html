<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: StaffInfo.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: StaffInfo.js</h1>

    


    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/*
 * StaffInfo.js Author: Zoltan Komives (zolaemil@gmail.com) Created: 03.07.2013
 *
 * Copyright © 2012, 2013 Richard Lewis, Raffaele Viglianti, Zoltan Komives,
 * University of Maryland
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

var MEI2VF = ( function(m2v, VF, $, undefined) {

    /**
     * @class MEI2VF.StaffInfo
     * Contains the definition and the rendering information (i.e. what
     * clef modifiers are to be rendered) of a single staff
     * @private
     *
     * @constructor
     * @param staffdef
     * @param w_clef
     * @param w_keysig
     * @param w_timesig
     */
    m2v.StaffInfo = function(staffdef, w_clef, w_keysig, w_timesig) {
      var me = this;
      me.renderWith = {
        clef : w_clef,
        keysig : w_keysig,
        timesig : w_timesig
      };
      me.spacing = null;
      me.staffDefObj = m2v.Util.attsToObj(staffdef);
      me.updateMeter();
      me.updateStaveLabels();
      me.updateSpacing();
      me.currentClef = me.convertClef();
    };

    m2v.StaffInfo.prototype = {

      updateMeter : function() {
        var me = this;
        if (me.staffDefObj.hasOwnProperty('meter.count') &amp;&amp; me.staffDefObj.hasOwnProperty('meter.unit')) {
          me.meter = {
            count : +me.staffDefObj['meter.count'],
            unit : +me.staffDefObj['meter.unit']
          };
        }
      },

      updateStaveLabels : function() {
        var me = this, label, labelAbbr;
        label = me.staffDefObj.label;
        if ( typeof label === 'string')
          me.label = label;
        labelAbbr = me.staffDefObj['label.abbr'];
        if ( typeof labelAbbr === 'string')
          me.labelAbbr = labelAbbr;
      },

      updateSpacing : function() {
        var me = this, spacing;
        spacing = +me.staffDefObj.spacing;
        if (!isNaN(spacing))
          me.spacing = spacing;
        return me.spacing;
      },

      forceSectionStartInfo : function() {
        var me = this;
        me.renderWith.clef = true;
        me.renderWith.keysig = true;
        me.renderWith.timesig = true;
      },

      forceStaveStartInfo : function() {
        var me = this;
        me.renderWith.clef = true;
        me.renderWith.keysig = true;
      },

      showClefCheck : function() {
        var me = this;
        if (me.renderWith.clef &amp;&amp; me.staffDefObj['clef.visible'] !== 'false') {
          me.renderWith.clef = false;
          return true;
        }
      },

      showKeysigCheck : function() {
        var me = this;
        if (me.renderWith.keysig) {
          me.renderWith.keysig = false;
          if (me.staffDefObj['key.sig.show'] !== 'false')
            return true;
        }
      },

      showTimesigCheck : function() {
        var me = this;
        if (me.renderWith.timesig) {
          me.renderWith.timesig = false;
          if (me.staffDefObj['meter.rend'] === 'norm' || me.staffDefObj['meter.rend'] === undefined) {
            return true;
          }
        }
      },

      convertClef : function() {
        var me = this, clef_shape, clef_line, clef_dis, clef_dis_place;
        clef_shape = me.staffDefObj['clef.shape'];
        if (!clef_shape) {
          throw new m2v.RUNTIME_ERROR('MEI2VF.RERR.MissingAttribute', 'Attribute clef.shape is mandatory.');
        }
        clef_line = me.staffDefObj['clef.line'];
        clef_dis = me.staffDefObj['clef.dis'];
        clef_dis_place = me.staffDefObj['clef.dis.place'];
        if (clef_shape === 'G' &amp;&amp; (!clef_line || clef_line === '2')) {
          if (clef_dis === '8' &amp;&amp; clef_dis_place === 'below' &amp;&amp; VF.clefProperties.values.octave != undefined) {
            return 'octave';
          }
          return 'treble';
        }
        if (clef_shape === 'F' &amp;&amp; (!clef_line || clef_line === '4'))
          return 'bass';
        if (clef_shape === 'C' &amp;&amp; clef_line === '3')
          return 'alto';
        if (clef_shape === 'C' &amp;&amp; clef_line === '4')
          return 'tenor';
        throw new m2v.RUNTIME_ERROR('MEI2VF.RERR.NotSupported', 'Clef definition is not supported: [ clef.shape="' + clef_shape + '" ' + ( clef_line ? ('clef.line="' + clef_line + '"') : '') + ' ]');
      },

      getClef : function() {
        return this.currentClef;
      },

      getKeySpec : function() {
        var me = this, keyname, key_accid, key_mode;
        if (me.staffDefObj['key.pname'] !== undefined) {
          keyname = me.staffDefObj['key.pname'].toUpperCase();
          key_accid = me.staffDefObj['key.accid'];
          if (key_accid !== undefined) {
            switch (key_accid) {
              case 's' :
                keyname += '#';
                break;
              case 'f' :
                keyname += 'b';
                break;
              default :
                throw new m2v.RUNTIME_ERROR('MEI2VF.RERR.UnexpectedAttributeValue', "Value of key.accid must be 's' or 'f'");
            }
          }
          key_mode = me.staffDefObj['key.mode'];
          if (key_mode !== undefined)
            keyname += (key_mode === 'major') ? '' : 'm';
          return keyname;
        }
        return 'C';
      },

      /**
       * gets the vexFlow time signature from an MEI staffDef element
       *
       * @return {String} the vexFlow time signature or undefined
       */
      getTimeSig : function() {
        var me = this, symbol, count, unit;
        symbol = me.staffDefObj['meter.sym'];
        if (symbol)
          return (symbol === 'cut') ? 'C|' : 'C';
        count = me.staffDefObj['meter.count'];
        unit = me.staffDefObj['meter.unit'];
        return (count &amp;&amp; unit) ? count + '/' + unit : undefined;
      },

      updateRenderWith : function(newStaffDef) {
        var me = this, result, hasEqualAtt;

        result = {
          clef : false,
          keysig : false,
          timesig : false
        };

        // if (Object.keys(newStaffDef).length === 0) {
        // return result;
        // }

        hasEqualAtt = function(attr_name) {
          return me.staffDefObj[attr_name] === newStaffDef[attr_name];
        };

        if (!hasEqualAtt('clef.shape') || !hasEqualAtt('clef.line')) {
          result.clef = true;
        }
        if ((!hasEqualAtt('key.pname') || !hasEqualAtt('key.accid') || !hasEqualAtt('key.mode'))) {
          result.keysig = true;
        }
        if (!hasEqualAtt('meter.count') || !hasEqualAtt('meter.unit')) {
          result.timesig = true;
        }

        me.renderWith = result;
      },

      updateDef : function(staffDef) {
        var me = this, newStaffDef;
        newStaffDef = m2v.Util.attsToObj(staffDef);
        me.updateRenderWith(newStaffDef);
        me.staffDefObj = newStaffDef;
        me.updateMeter();
        me.updateStaveLabels();
        me.updateSpacing();
        me.currentClef = me.convertClef();
      }
    };

    return m2v;

  }(MEI2VF || {}, Vex.Flow, jQuery));
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Classes</h3><ul><li><a href="m2v.Converter.html">Converter</a></li><li><a href="MEI2VF.html">MEI2VF</a></li><li><a href="MeiLib.html">MeiLib</a></li><li><a href="MeiLib.Alt.html">Alt</a></li><li><a href="MeiLib.EventEnumerator.html">EventEnumerator</a></li><li><a href="MeiLib.MeiDoc.html">MeiDoc</a></li><li><a href="MeiLib.RuntimeError.html">RuntimeError</a></li><li><a href="MeiLib.Variant.html">Variant</a></li><li><a href="Vex.Flow.Hyphen.html">Hyphen</a></li><li><a href="Vex.Flow.StaveTie.html">StaveTie</a></li></ul><h3>Global</h3><ul><li><a href="global.html#addArticulation">addArticulation</a></li><li><a href="global.html#addFermata">addFermata</a></li><li><a href="global.html#addStaffModifiers">addStaffModifiers</a></li><li><a href="global.html#addStaffVolta">addStaffVolta</a></li><li></li><li><a href="global.html#createAnnot">createAnnot</a></li><li><a href="global.html#createNewSystem">createNewSystem</a></li><li><a href="global.html#createPseudoUUID">createPseudoUUID</a></li><li><a href="global.html#createVexStaff">createVexStaff</a></li><li><a href="global.html#createVexVoice">createVexVoice</a></li><li></li><li><a href="global.html#draw">draw</a></li><li><a href="global.html#drawSystems">drawSystems</a></li><li><a href="global.html#drawVexBeams">drawVexBeams</a></li><li></li><li></li><li><a href="global.html#getAllVexMeasureStaffs">getAllVexMeasureStaffs</a></li><li><a href="global.html#getALTs">getALTs</a></li><li><a href="global.html#getEditorList">getEditorList</a></li><li><a href="global.html#getMandatoryAttr">getMandatoryAttr</a></li><li><a href="global.html#getNotes">getNotes</a></li><li><a href="global.html#getPlainScore">getPlainScore</a></li><li><a href="global.html#getRichScore">getRichScore</a></li><li><a href="global.html#getRichSliceGet a slice of the whole rich MEI document.">getRichSliceGet a slice of the whole rich MEI document.</a></li><li><a href="global.html#getSectionViewSliceGet a slice of the sectionview_score.">getSectionViewSliceGet a slice of the sectionview_score.</a></li><li><a href="global.html#getSourceList">getSourceList</a></li><li><a href="global.html#getStaffArea">getStaffArea</a></li><li><a href="global.html#getStaffLabels">getStaffLabels</a></li><li><a href="global.html#getSystems">getSystems</a></li><li></li><li><a href="global.html#init">init</a></li><li></li><li><a href="global.html#initAltgroups">initAltgroups</a></li><li><a href="global.html#initConfig">initConfig</a></li><li></li><li><a href="global.html#nextEvent">nextEvent</a></li><li><a href="global.html#parse_slure_attribute">parse_slure_attribute</a></li><li></li><li><a href="global.html#parseEditorList">parseEditorList</a></li><li><a href="global.html#parseSourceListExtracts information about the sources as defined in the MEI header.">parseSourceListExtracts information about the sources as defined in the MEI header.</a></li><li><a href="global.html#process">process</a></li><li><a href="global.html#processAnchoredLayerText">processAnchoredLayerText</a></li><li><a href="global.html#processAnchoredStaffText">processAnchoredStaffText</a></li><li><a href="global.html#processAttrAccid">processAttrAccid</a></li><li><a href="global.html#processAttrHo">processAttrHo</a></li><li><a href="global.html#processAttrSlur">processAttrSlur</a></li><li><a href="global.html#processAttrTie">processAttrTie</a></li><li><a href="global.html#processAttsDuration">processAttsDuration</a></li><li><a href="global.html#processAttsPitch">processAttsPitch</a></li><li><a href="global.html#processBeam">processBeam</a></li><li><a href="global.html#processChord">processChord</a></li><li><a href="global.html#processEnding">processEnding</a></li><li><a href="global.html#processMeasure">processMeasure</a></li><li><a href="global.html#processmRest">processmRest</a></li><li><a href="global.html#processNote">processNote</a></li><li><a href="global.html#processNoteInChord">processNoteInChord</a></li><li><a href="global.html#processNoteLikeElement">processNoteLikeElement</a></li><li><a href="global.html#processRest">processRest</a></li><li><a href="global.html#processSection">processSection</a></li><li><a href="global.html#processSectionChild">processSectionChild</a></li><li><a href="global.html#processSections">processSections</a></li><li><a href="global.html#processSpace">processSpace</a></li><li><a href="global.html#processStaffInMeasure">processStaffInMeasure</a></li><li><a href="global.html#processSyllable">processSyllable</a></li><li><a href="global.html#processSyllables">processSyllables</a></li><li><a href="global.html#read_ahead">read_ahead</a></li><li><a href="global.html#replaceAltInstanceReplace an alternative instance in the sectionview score and in thesectionplane">replaceAltInstanceReplace an alternative instance in the sectionview score and in thesectionplane</a></li><li><a href="global.html#reset">reset</a></li><li><a href="global.html#resolveUnresolvedTimestamps">resolveUnresolvedTimestamps</a></li><li><a href="global.html#setAnchoredTextProcessor">setAnchoredTextProcessor</a></li><li><a href="global.html#setLogging enables or disables MEI2VF logging">setLogging enables or disables MEI2VF logging</a></li><li><a href="global.html#setPendingSystemBreak">setPendingSystemBreak</a></li><li><a href="global.html#setPgHeadProcessor">setPgHeadProcessor</a></li><li><a href="global.html#setStemDir">setStemDir</a></li><li></li><li><a href="global.html#step_ahead">step_ahead</a></li><li></li><li><a href="global.html#toString">toString</a></li><li><a href="global.html#translateDuration">translateDuration</a></li><li><a href="global.html#tstamp2idFind the event with the minimum distance from of the given timestamp.">tstamp2idFind the event with the minimum distance from of the given timestamp.</a></li><li></li><li><a href="global.html#XMLIDreturns the xml:id attribute of an element; if there is none, the functioncreated a pseudo id, adds it to the element and returns that id.">XMLIDreturns the xml:id attribute of an element; if there is none, the functioncreated a pseudo id, adds it to the element and returns that id.</a></li></ul>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0-alpha5</a> on Sat May 10 2014 06:02:53 GMT+0200 (Mitteleuropäische Sommerzeit)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
