<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: System.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: System.js</h1>

    


    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>var MEI2VF = ( function(m2v, VF, $, undefined) {

    // TODO width calculation: take end modifiers into account (do this later: end
    // modifiers are currently not part of mei2vf)

    /**
     * A single instance of a staff system, containing and processing information
     * about the measures contained
     * @class MEI2VF.System
     * @private
     *
     * @constructor
     * @param {Object} config The configuration object
     */
    m2v.System = function(config) {
      this.init(config);
    };

    m2v.System.prototype = {

      /**
       * @property {Number} LABEL_PADDING the padding (in pixels) between the voice
       * labels and the staves
       */
      LABEL_PADDING : 20,

      /**
       * @param {Object} config The configuration object
       */
      init : function(config) {
        var me = this;

        /**
         * @cfg {Number|null} leftMar the left system margin as specified in the
         * MEI file or null if there is no margin specified. In the latter case,
         * the margin will be calculated on basis of the text width of the labels
         */
        me.leftMar = config.leftMar;
        /**
         * @cfg {Object} coords the coords of the current system
         * @cfg {Number} coords.x the x coordinate of the system
         * @cfg {Number} coords.y the y coordinate of the system
         * @cfg {Number} coords.w the system width
         */
        me.coords = config.coords;
        /**
         * @cfg {Number[]} staffYs the y coordinates of all staffs in the current
         * system
         */
        me.staffYs = config.staffYs;
        /**
         * @cfg {String[]} labels the labels of all staffs in the current system
         */
        me.labels = config.labels;
        /**
         * @property {MEI2VF.Measure[]} measures the measures in the current
         * system
         */
        me.measures = [];
      },

      /**
       * @return {Number[]} the value of {@link #staffYs}
       */
      getStaffYs : function() {
        return this.staffYs;
      },

      /**
       * adds a measure to the end of the measure array
       * @param {MEI2VF.Measure} measure the measure to add
       */
      addMeasure : function(measure) {
        this.measures.push(measure);
      },

      /**
       * gets a measure in the current system at the specified index
       * @param {Number} i the measure index (the first measure in the current
       * system has the index 0)
       * @return {MEI2VF.Measure}
       */
      getMeasure : function(i) {
        return this.measures[i];
      },

      /**
       * gets all measures in the current system
       * @return {MEI2VF.Measure[]}
       */
      getMeasures : function() {
        return this.measures;
      },

      /**
       * Calculates the system indent based on the width of the stave and
       * stave-connector labels
       * @param {Object} ctx the canvas context
       */
      calculateInitialIndent : function(ctx) {
        var me = this, label, max = 0, w, connectors, i, text;
        ctx.setFont('Times', 16);
        for (label in me.labels) {
          text = me.labels[label];
          if ( typeof text === 'string') {
            w = ctx.measureText(me.labels[label]).width;
            if (max &lt; w) {
              max = w;
            }
          }
        }
        connectors = me.getMeasures()[0].startConnectors.getAll();
        i = connectors.length;
        while (i--) {
          text = connectors[i].text;
          if ( typeof text === 'string') {
            w = ctx.measureText(me.labels[label]).width;
            if (max &lt; w) {
              max = w;
            }
          }
        }
        me.leftMar = (max === 0) ? 0 : max + me.LABEL_PADDING;
      },

      /**
       * Calculates the minimum width of each measure in the current system
       */
      calculateMeasureMinWidths : function() {
        var measures = this.measures, i = measures.length;
        while (i--) {
          measures[i].calculateMinWidth();
        }
      },

      /**
       * calculates the width of all measures in a stave which don't have a
       * specified width in the MEI code and writes them to their enclosing
       * measure object
       */
      calculateMissingMeasureWidths : function() {
        var me = this, i, j, totalSpecifiedMeasureWidth = 0, avaliableSingleWidth, nonSpecified_n = 0;
        for ( i = 0, j = me.measures.length; i &lt; j; i += 1) {
          if (me.measures[i].meiW === null) {
            nonSpecified_n += 1;
            totalSpecifiedMeasureWidth += me.measures[i].getMinWidth();
          } else {
            totalSpecifiedMeasureWidth += me.measures[i].meiW;
          }
        }
        avaliableSingleWidth = Math.floor((me.coords.w - me.leftMar - totalSpecifiedMeasureWidth) / nonSpecified_n);
        for ( i = 0, j = me.measures.length; i &lt; j; i += 1) {
          if (me.measures[i].meiW === null) {
            me.measures[i].w = avaliableSingleWidth + me.measures[i].getMinWidth();
          } else {
            me.measures[i].w = me.measures[i].meiW;
          }
        }
      },

      /**
       * formats the measures in the current system
       * @param {Object} ctx the canvas context
       * @return {MEI2VF.System} this
       */
      format : function(ctx) {
        var me = this, i, j, measures, offsetX, labels;
        if ( typeof me.leftMar !== 'number') {
          me.calculateInitialIndent(ctx);
        }
        me.calculateMeasureMinWidths();
        me.calculateMissingMeasureWidths();
        offsetX = me.coords.x + me.leftMar;
        measures = me.getMeasures();
        for ( i = 0, j = measures.length; i &lt; j; i += 1) {
          if (measures[i]) {
            labels = (i === 0) ? me.labels : null;
            measures[i].format(offsetX, labels);
            offsetX += measures[i].w;
          }
          measures[i].addTempoToStaves();
        }
        return me;
      },

      /**
       * draws the current system to a canvas
       * @param {Object} ctx the canvas context
       */
      draw : function(ctx) {
        var me = this, i = me.measures.length;
        while (i--) {
          if (me.measures[i]) {
            me.measures[i].draw(ctx);
          }
        }
      }
    };

    return m2v;

  }(MEI2VF || {}, Vex.Flow, jQuery));
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Classes</h3><ul><li><a href="m2v.Converter.html">Converter</a></li><li><a href="MEI2VF.html">MEI2VF</a></li><li><a href="MeiLib.html">MeiLib</a></li><li><a href="MeiLib.Alt.html">Alt</a></li><li><a href="MeiLib.EventEnumerator.html">EventEnumerator</a></li><li><a href="MeiLib.MeiDoc.html">MeiDoc</a></li><li><a href="MeiLib.RuntimeError.html">RuntimeError</a></li><li><a href="MeiLib.Variant.html">Variant</a></li><li><a href="Vex.Flow.Hyphen.html">Hyphen</a></li><li><a href="Vex.Flow.StaveTie.html">StaveTie</a></li></ul><h3>Global</h3><ul><li><a href="global.html#addArticulation">addArticulation</a></li><li><a href="global.html#addFermata">addFermata</a></li><li><a href="global.html#addStaffModifiers">addStaffModifiers</a></li><li><a href="global.html#addStaffVolta">addStaffVolta</a></li><li></li><li><a href="global.html#createAnnot">createAnnot</a></li><li><a href="global.html#createNewSystem">createNewSystem</a></li><li><a href="global.html#createPseudoUUID">createPseudoUUID</a></li><li><a href="global.html#createVexStaff">createVexStaff</a></li><li><a href="global.html#createVexVoice">createVexVoice</a></li><li></li><li><a href="global.html#draw">draw</a></li><li><a href="global.html#drawSystems">drawSystems</a></li><li><a href="global.html#drawVexBeams">drawVexBeams</a></li><li></li><li></li><li><a href="global.html#getAllVexMeasureStaffs">getAllVexMeasureStaffs</a></li><li><a href="global.html#getALTs">getALTs</a></li><li><a href="global.html#getEditorList">getEditorList</a></li><li><a href="global.html#getMandatoryAttr">getMandatoryAttr</a></li><li><a href="global.html#getNotes">getNotes</a></li><li><a href="global.html#getPlainScore">getPlainScore</a></li><li><a href="global.html#getRichScore">getRichScore</a></li><li><a href="global.html#getRichSliceGet a slice of the whole rich MEI document.">getRichSliceGet a slice of the whole rich MEI document.</a></li><li><a href="global.html#getSectionViewSliceGet a slice of the sectionview_score.">getSectionViewSliceGet a slice of the sectionview_score.</a></li><li><a href="global.html#getSourceList">getSourceList</a></li><li><a href="global.html#getStaffArea">getStaffArea</a></li><li><a href="global.html#getStaffLabels">getStaffLabels</a></li><li><a href="global.html#getSystems">getSystems</a></li><li></li><li><a href="global.html#init">init</a></li><li></li><li><a href="global.html#initAltgroups">initAltgroups</a></li><li><a href="global.html#initConfig">initConfig</a></li><li></li><li><a href="global.html#nextEvent">nextEvent</a></li><li><a href="global.html#parse_slure_attribute">parse_slure_attribute</a></li><li></li><li><a href="global.html#parseEditorList">parseEditorList</a></li><li><a href="global.html#parseSourceListExtracts information about the sources as defined in the MEI header.">parseSourceListExtracts information about the sources as defined in the MEI header.</a></li><li><a href="global.html#process">process</a></li><li><a href="global.html#processAnchoredLayerText">processAnchoredLayerText</a></li><li><a href="global.html#processAnchoredStaffText">processAnchoredStaffText</a></li><li><a href="global.html#processAttrAccid">processAttrAccid</a></li><li><a href="global.html#processAttrHo">processAttrHo</a></li><li><a href="global.html#processAttrSlur">processAttrSlur</a></li><li><a href="global.html#processAttrTie">processAttrTie</a></li><li><a href="global.html#processAttsDuration">processAttsDuration</a></li><li><a href="global.html#processAttsPitch">processAttsPitch</a></li><li><a href="global.html#processBeam">processBeam</a></li><li><a href="global.html#processChord">processChord</a></li><li><a href="global.html#processEnding">processEnding</a></li><li><a href="global.html#processMeasure">processMeasure</a></li><li><a href="global.html#processmRest">processmRest</a></li><li><a href="global.html#processNote">processNote</a></li><li><a href="global.html#processNoteInChord">processNoteInChord</a></li><li><a href="global.html#processNoteLikeElement">processNoteLikeElement</a></li><li><a href="global.html#processRest">processRest</a></li><li><a href="global.html#processSection">processSection</a></li><li><a href="global.html#processSectionChild">processSectionChild</a></li><li><a href="global.html#processSections">processSections</a></li><li><a href="global.html#processSpace">processSpace</a></li><li><a href="global.html#processStaffInMeasure">processStaffInMeasure</a></li><li><a href="global.html#processSyllable">processSyllable</a></li><li><a href="global.html#processSyllables">processSyllables</a></li><li><a href="global.html#read_ahead">read_ahead</a></li><li><a href="global.html#replaceAltInstanceReplace an alternative instance in the sectionview score and in thesectionplane">replaceAltInstanceReplace an alternative instance in the sectionview score and in thesectionplane</a></li><li><a href="global.html#reset">reset</a></li><li><a href="global.html#resolveUnresolvedTimestamps">resolveUnresolvedTimestamps</a></li><li><a href="global.html#setAnchoredTextProcessor">setAnchoredTextProcessor</a></li><li><a href="global.html#setLogging enables or disables MEI2VF logging">setLogging enables or disables MEI2VF logging</a></li><li><a href="global.html#setPendingSystemBreak">setPendingSystemBreak</a></li><li><a href="global.html#setPgHeadProcessor">setPgHeadProcessor</a></li><li><a href="global.html#setStemDir">setStemDir</a></li><li></li><li><a href="global.html#step_ahead">step_ahead</a></li><li></li><li><a href="global.html#toString">toString</a></li><li><a href="global.html#translateDuration">translateDuration</a></li><li><a href="global.html#tstamp2idFind the event with the minimum distance from of the given timestamp.">tstamp2idFind the event with the minimum distance from of the given timestamp.</a></li><li></li><li><a href="global.html#XMLIDreturns the xml:id attribute of an element; if there is none, the functioncreated a pseudo id, adds it to the element and returns that id.">XMLIDreturns the xml:id attribute of an element; if there is none, the functioncreated a pseudo id, adds it to the element and returns that id.</a></li></ul>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0-alpha5</a> on Sat May 10 2014 06:02:53 GMT+0200 (Mitteleuropäische Sommerzeit)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
