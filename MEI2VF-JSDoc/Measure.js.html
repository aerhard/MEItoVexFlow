<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: Measure.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: Measure.js</h1>

    


    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>var MEI2VF = ( function(m2v, VF, $, undefined) {

    /**
     * @class MEI2VF.Measure
     * @private
     *
     * @constructor
     * @param {Object} config The configuration object
     */
    m2v.Measure = function(config) {
      this.init(config);
    };

    m2v.Measure.prototype = {

      // currently fixed
      /**
       * @property
       */
      HALF_LINE_DISTANCE : 5, // VF.Staff.spacing_between_lines_px / 2;

      /**
       * initializes the current MEI2VF.Measure object
       * @param {Object} config The configuration object
       */
      init : function(config) {
        var me = this;
        /**
         * @cfg {XMLElement} element the MEI element of the current measure
         */
        me.element = config.element;
        /**
         * @cfg {Number} n The number of the current measure as specified in
         * the MEI document
         */
        me.n = config.n;
        // TODO instead of passing the staff contents in the config object, use a method addToMeasure!?!
        /**
         * @cfg {Array} staffs an array of the staffs in the current
         * measure. Contains
         */
        me.staffs = config.staffs;
        /**
         * @cfg {MEI2VF.StaveVoices} voices The voices of all staffs in the
         * current measure
         */
        me.voices = config.voices;
        /**
         * @cfg {MEI2VF.Connectors} startConnectors an instance of
         * MEI2VF.Connectors handling all left connectors (only the first measure
         * in a system has data)
         */
        me.startConnectors = new m2v.Connectors(config.startConnectorCfg);
        /**
         * @cfg {MEI2VF.Connectors} inlineConnectors an instance of
         * MEI2VF.Connectors handling all right connectors
         */
        me.inlineConnectors = new m2v.Connectors(config.inlineConnectorCfg);

        me.tieElements = config.tieElements;
        me.slurElements = config.slurElements;
        me.hairpinElements = config.hairpinElements;
        /**
         * @cfg {XMLElement[]} tempoElements the MEI tempo elements in the
         * current
         * measure
         */
        me.tempoElements = config.tempoElements;
        /**
         * @cfg {Object} tempoFont the font used for rendering tempo
         * specifications
         */
        me.tempoFont = config.tempoFont;
        /**
         * @property {Number} maxNoteStartX the maximum note_start_x value of all
         * Vex.Flow.Stave objects in the current measure
         */
        me.maxNoteStartX = 0;
        /**
         * @property {Number} meiW the width attribute of the measure element or
         * null if NaN
         */
        me.meiW = me.readMEIW(me.element);
      },

      /**
       *  reads the width attribute of the specified element and converts it to a
       * number
       * @param {XMLElement} element the element to process
       * @return {Number} the number of the attribute or null if NaN
       */
      readMEIW : function(element) {
        return +element.getAttribute('width') || null;
      },

      /**
       * gets the staffs array of the current measure
       * @return {Array}
       */
      getStaffs : function() {
        return this.staffs;
      },

      /**
       * gets the voices object of the current measure
       * @return {MEI2VF.StaveVoices}
       */
      getVoices : function() {
        return this.voices;
      },

      /**
       * gets the x coordinate of the staff
       * @return {Number}
       */
      getX : function() {
        return this.getFirstDefinedStaff().x;
      },

      /**
       * gets the number of the current staff as specified in the MEI code
       * @return {Number}
       */
      getN : function() {
        return this.n;
      },

      /**
       * gets the first defined staff in the current measure
       * @return {Vex.Flow.Stave}
       */
      getFirstDefinedStaff : function() {
        var me = this, i, j;
        for ( i = 0, j = me.staffs.length; i &lt; j; i += 1) {
          if (me.staffs[i]) {
            return me.staffs[i];
          }
        }
        throw new m2v.RUNTIME_ERROR('ERROR', 'getFirstDefinedStaff(): no staff found in the current measure.');
      },

      // TODO handle timestamps! (is it necessary to handle tempo element
      // as annotations?)
      // TODO make magic numbers constants
      /**
       * Writes the data of the tempo elements in the current measure to the
       * corresponding Vex.Flow.Stave object
       */
      addTempoToStaves : function() {
        var me = this, offsetX, vexStaff, vexTempo, atts;
        $.each(me.tempoElements, function() {
          atts = m2v.Util.attsToObj(this);
          vexStaff = me.staffs[atts.staff];
          vexTempo = new Vex.Flow.StaveTempo({
            name : $(this).text(),
            duration : atts['mm.unit'],
            dots : +atts['mm.dots'],
            bpm : +atts.mm
          }, vexStaff.x, 5);
          if (atts.vo)
            vexTempo.setShiftY(+atts.vo * me.HALF_LINE_DISTANCE);
          offsetX = (vexStaff.getModifierXShift() > 0) ? -14 : 14;
          if ( typeof vexStaff.timeSigIndex === 'number')
            offsetX -= 24;
          if (atts.ho)
            offsetX += +atts.ho * me.HALF_LINE_DISTANCE;
          vexTempo.setShiftX(offsetX);
          vexTempo.font = me.tempoFont;
          vexStaff.modifiers.push(vexTempo);
        });
      },

      /**
       * calculates the minimum width of the current measure
       */
      calculateMinWidth : function() {
        var me = this;
        me.calculateMaxNoteStartX();
        me.calculateRepeatPadding();
        /**
         * @property
         */
        me.minVoicesW = me.voices.preFormat();
        /**
         * @property
         */
        me.minWidth = me.maxNoteStartX + me.minVoicesW + me.repeatPadding;
      },

      /**
       * gets the minimum width of the current measure;
       */
      getMinWidth : function() {
        return this.minWidth;
      },

      /**
       * calculates the maximum note_start_x of all Vex.Flow.Stave objects in the
       * current measure
       */
      calculateMaxNoteStartX : function() {
        var me = this, i, staffs, staff;
        staffs = me.staffs;
        i = staffs.length;
        while (i--) {
          staff = staffs[i];
          if (staff) {
            me.maxNoteStartX = Math.max(me.maxNoteStartX, staff.getNoteStartX());
          }
        }
      },

      /**
       * calculates additional start padding when there are repetition start bars
       * in the current measure
       */
      calculateRepeatPadding : function() {
        var me = this;
        var staff = me.getFirstDefinedStaff();
        /**
         * @property
         */
        me.repeatPadding = (staff.modifiers[0].barline == Vex.Flow.Barline.type.REPEAT_BEGIN &amp;&amp; staff.modifiers.length > 2) ? 20 : 0;
      },

      // TODO align start modifiers (changes in vexflow necessary??)

      // TODO move label attachment somewhere else
      /**
       * Formats the staffs in the current measure: sets x coordinates and adds
       * staff labels
       * @param {Number} x The x coordinate of the the measure
       * @param {String[]} labels The labels of all staves
       */
      format : function(x, labels) {
        var me = this, width = me.w, i = me.staffs.length;
        while (i--) {
          if (me.staffs[i]) {
            staff = me.staffs[i];
            if (labels &amp;&amp; typeof labels[i] === 'string') {
              staff.setText(labels[i], VF.Modifier.Position.LEFT, {
                shift_y : -3
              });
            }
            staff.x += x;
            staff.glyph_start_x += x;
            staff.start_x = staff.x + me.maxNoteStartX;
            staff.bounds.x += x;
            staff.setWidth(width);
            staff.modifiers[0].x += x;
            // staff.end_x += x + offsetW;
            // staff.glyph_end_x += x + offsetW;
          }
        }
        me.voices.format(me.getFirstDefinedStaff());
      },

      /**
       * Draws the staffs, voices and connectors in the current measure to a
       * canvas
       * @param {Object} ctx the canvas context
       */
      draw : function(ctx) {
        var me = this, i, staffs, staff;
        staffs = me.staffs;
        i = staffs.length;
        while (i--) {
          staff = staffs[i];
          if (staff) {
            staff.setContext(ctx).draw();
          }
        }
        me.voices.draw(ctx, staffs);
        me.startConnectors.setContext(ctx).draw();
        me.inlineConnectors.setContext(ctx).draw();
      }
    };

    return m2v;

  }(MEI2VF || {}, Vex.Flow, jQuery));
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Classes</h3><ul><li><a href="m2v.Converter.html">Converter</a></li><li><a href="MEI2VF.html">MEI2VF</a></li><li><a href="MeiLib.html">MeiLib</a></li><li><a href="MeiLib.Alt.html">Alt</a></li><li><a href="MeiLib.EventEnumerator.html">EventEnumerator</a></li><li><a href="MeiLib.MeiDoc.html">MeiDoc</a></li><li><a href="MeiLib.RuntimeError.html">RuntimeError</a></li><li><a href="MeiLib.Variant.html">Variant</a></li><li><a href="Vex.Flow.Hyphen.html">Hyphen</a></li><li><a href="Vex.Flow.StaveTie.html">StaveTie</a></li></ul><h3>Global</h3><ul><li><a href="global.html#addArticulation">addArticulation</a></li><li><a href="global.html#addFermata">addFermata</a></li><li><a href="global.html#addStaffModifiers">addStaffModifiers</a></li><li><a href="global.html#addStaffVolta">addStaffVolta</a></li><li></li><li><a href="global.html#createAnnot">createAnnot</a></li><li><a href="global.html#createNewSystem">createNewSystem</a></li><li><a href="global.html#createPseudoUUID">createPseudoUUID</a></li><li><a href="global.html#createVexStaff">createVexStaff</a></li><li><a href="global.html#createVexVoice">createVexVoice</a></li><li></li><li><a href="global.html#draw">draw</a></li><li><a href="global.html#drawSystems">drawSystems</a></li><li><a href="global.html#drawVexBeams">drawVexBeams</a></li><li></li><li></li><li><a href="global.html#getAllVexMeasureStaffs">getAllVexMeasureStaffs</a></li><li><a href="global.html#getALTs">getALTs</a></li><li><a href="global.html#getEditorList">getEditorList</a></li><li><a href="global.html#getMandatoryAttr">getMandatoryAttr</a></li><li><a href="global.html#getNotes">getNotes</a></li><li><a href="global.html#getPlainScore">getPlainScore</a></li><li><a href="global.html#getRichScore">getRichScore</a></li><li><a href="global.html#getRichSliceGet a slice of the whole rich MEI document.">getRichSliceGet a slice of the whole rich MEI document.</a></li><li><a href="global.html#getSectionViewSliceGet a slice of the sectionview_score.">getSectionViewSliceGet a slice of the sectionview_score.</a></li><li><a href="global.html#getSourceList">getSourceList</a></li><li><a href="global.html#getStaffArea">getStaffArea</a></li><li><a href="global.html#getStaffLabels">getStaffLabels</a></li><li><a href="global.html#getSystems">getSystems</a></li><li></li><li><a href="global.html#init">init</a></li><li></li><li><a href="global.html#initAltgroups">initAltgroups</a></li><li><a href="global.html#initConfig">initConfig</a></li><li></li><li><a href="global.html#nextEvent">nextEvent</a></li><li><a href="global.html#parse_slure_attribute">parse_slure_attribute</a></li><li></li><li><a href="global.html#parseEditorList">parseEditorList</a></li><li><a href="global.html#parseSourceListExtracts information about the sources as defined in the MEI header.">parseSourceListExtracts information about the sources as defined in the MEI header.</a></li><li><a href="global.html#process">process</a></li><li><a href="global.html#processAnchoredLayerText">processAnchoredLayerText</a></li><li><a href="global.html#processAnchoredStaffText">processAnchoredStaffText</a></li><li><a href="global.html#processAttrAccid">processAttrAccid</a></li><li><a href="global.html#processAttrHo">processAttrHo</a></li><li><a href="global.html#processAttrSlur">processAttrSlur</a></li><li><a href="global.html#processAttrTie">processAttrTie</a></li><li><a href="global.html#processAttsDuration">processAttsDuration</a></li><li><a href="global.html#processAttsPitch">processAttsPitch</a></li><li><a href="global.html#processBeam">processBeam</a></li><li><a href="global.html#processChord">processChord</a></li><li><a href="global.html#processEnding">processEnding</a></li><li><a href="global.html#processMeasure">processMeasure</a></li><li><a href="global.html#processmRest">processmRest</a></li><li><a href="global.html#processNote">processNote</a></li><li><a href="global.html#processNoteInChord">processNoteInChord</a></li><li><a href="global.html#processNoteLikeElement">processNoteLikeElement</a></li><li><a href="global.html#processRest">processRest</a></li><li><a href="global.html#processSection">processSection</a></li><li><a href="global.html#processSectionChild">processSectionChild</a></li><li><a href="global.html#processSections">processSections</a></li><li><a href="global.html#processSpace">processSpace</a></li><li><a href="global.html#processStaffInMeasure">processStaffInMeasure</a></li><li><a href="global.html#processSyllable">processSyllable</a></li><li><a href="global.html#processSyllables">processSyllables</a></li><li><a href="global.html#read_ahead">read_ahead</a></li><li><a href="global.html#replaceAltInstanceReplace an alternative instance in the sectionview score and in thesectionplane">replaceAltInstanceReplace an alternative instance in the sectionview score and in thesectionplane</a></li><li><a href="global.html#reset">reset</a></li><li><a href="global.html#resolveUnresolvedTimestamps">resolveUnresolvedTimestamps</a></li><li><a href="global.html#setAnchoredTextProcessor">setAnchoredTextProcessor</a></li><li><a href="global.html#setLogging enables or disables MEI2VF logging">setLogging enables or disables MEI2VF logging</a></li><li><a href="global.html#setPendingSystemBreak">setPendingSystemBreak</a></li><li><a href="global.html#setPgHeadProcessor">setPgHeadProcessor</a></li><li><a href="global.html#setStemDir">setStemDir</a></li><li></li><li><a href="global.html#step_ahead">step_ahead</a></li><li></li><li><a href="global.html#toString">toString</a></li><li><a href="global.html#translateDuration">translateDuration</a></li><li><a href="global.html#tstamp2idFind the event with the minimum distance from of the given timestamp.">tstamp2idFind the event with the minimum distance from of the given timestamp.</a></li><li></li><li><a href="global.html#XMLIDreturns the xml:id attribute of an element; if there is none, the functioncreated a pseudo id, adds it to the element and returns that id.">XMLIDreturns the xml:id attribute of an element; if there is none, the functioncreated a pseudo id, adds it to the element and returns that id.</a></li></ul>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0-alpha5</a> on Sat May 10 2014 06:02:53 GMT+0200 (Mitteleuropäische Sommerzeit)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
