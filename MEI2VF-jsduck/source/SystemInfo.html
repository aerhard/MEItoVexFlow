<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">var MEI2VF = ( function(m2v, VF, $, undefined) {

<span id='MEI2VF-SystemInfo-method-constructor'><span id='MEI2VF-SystemInfo'>    /**
</span></span>     * @class MEI2VF.SystemInfo
     * Deals with MEI data provided by scoreDef, staffDef and staffGrp elements and its children
     * @private
     *
     * @constructor

     */
    m2v.SystemInfo = function() {
      return;
    };

    m2v.SystemInfo.prototype = {

      // currently fixed
      STAVE_HEIGHT : 40, // VF.Staff.spacing_between_lines_px * 4;

      init : function(cfg, printSpace) {
        var me = this;
        me.cfg = cfg;
        me.printSpace = printSpace;

<span id='MEI2VF-SystemInfo-property-currentStaffInfos'>        /**
</span>         * contains the current {@link MEI2VF.StaffInfo} objects
         */
        me.currentStaffInfos = [];
<span id='MEI2VF-SystemInfo-property-systemLeftMar'>        /**
</span>         * @property {Number} systemLeftMar the left margin of the
         * current system (additional to the left print space margin)
         */
        me.systemLeftMar = undefined;
<span id='MEI2VF-SystemInfo-property-currentLowestY'>        /**
</span>         * @property {Number} currentLowestY the lowest Y coordinate of the
         * previously processed staffs
         */
        me.currentLowestY = 0;
        
        me.startConnectorInfos = {};
        me.inlineConnectorInfos = {}; 
        
      },

      setLeftMar : function(width) {
        this.systemLeftMar = width;
      },

      getLeftMar : function() {
        return this.systemLeftMar;
      },

      setModelForStaveRange : function(target, obj, add) {
        add = add || '';
        target[obj.top_staff_n + ':' + obj.bottom_staff_n + add] = obj;
      },

<span id='MEI2VF-SystemInfo-method-setConnectorModels'>      /**
</span>       *
       */
      setConnectorModels : function(staffGrp, range, isChild) {
        var me = this, symbol, barthru, first_n, last_n;

        first_n = range.first_n;
        last_n = range.last_n;
        symbol = $(staffGrp).attr('symbol');
        barthru = $(staffGrp).attr('barthru');

        m2v.L('Converter.setConnectorModels() {2}', 'symbol: ' + symbol, ' range.first_n: ' + first_n, ' range.last_n: ' + last_n);

        // # left connectors specified in the MEI file
        me.setModelForStaveRange(me.startConnectorInfos, {
          top_staff_n : first_n,
          bottom_staff_n : last_n,
          symbol : symbol || 'line',
          label : $(staffGrp).attr('label'),
          labelAbbr : $(staffGrp).attr('label.abbr')
        });

        // # left auto line, only (if at all) attached to
        // //staffGrp[not(ancestor::staffGrp)]
        if (!isChild &amp;&amp; me.cfg.autoStaveConnectorLine) {
          me.setModelForStaveRange(me.startConnectorInfos, {
            top_staff_n : first_n,
            bottom_staff_n : last_n,
            symbol : (symbol === 'none') ? 'none' : 'line'
          }, 'autoline');
        }

        // # inline connectors
        if (barthru === 'true') {
          me.setModelForStaveRange(me.inlineConnectorInfos, {
            top_staff_n : first_n,
            bottom_staff_n : last_n,
            symbol : 'singleright' // default
          });
        }
      },

      getStaffInfo : function(staff_n) {
        return this.currentStaffInfos[staff_n];
      },

      getAllStaffInfos : function() {
        return this.currentStaffInfos;
      },

<span id='MEI2VF-SystemInfo-method-getClef'>      /**
</span>       *
       */
      getClef : function(staff_n) {
        var me = this, staff_info;
        staff_info = me.currentStaffInfos[staff_n];
        if (!staff_info) {
          throw new m2v.RUNTIME_ERROR('MEI2VF.getClefForStaffNr():E01', 'No staff definition for staff n=' + staff_n);
        }
        return staff_info.getClef();
      },

      getCurrentLowestY : function() {
        return this.currentLowestY;
      },

      setCurrentLowestY : function(y) {
        this.currentLowestY = y;
      },

      getYs : function(currentSystemY) {
        var me = this, currentStaffY, i, j, isFirstStaff = true, infoSpacing, lowestYCandidate, ys = [];
        currentStaffY = 0;
        for ( i = 1, j = me.currentStaffInfos.length; i &lt; j; i += 1) {
          if (me.currentStaffInfos[i]) {
            infoSpacing = me.currentStaffInfos[i].spacing;
            currentStaffY += (isFirstStaff) ? 0 : (infoSpacing !== null) ? me.STAVE_HEIGHT + me.currentStaffInfos[i].spacing : me.STAVE_HEIGHT + me.cfg.staveSpacing;
            ys[i] = currentSystemY + currentStaffY;
            isFirstStaff = false;
          }
        }
        lowestYCandidate = currentSystemY + currentStaffY + me.STAVE_HEIGHT;
        if (lowestYCandidate &gt; me.currentLowestY)
          me.currentLowestY = lowestYCandidate;
        return ys;
      },

      forceSectionStartInfos : function() {
        var me = this, i = me.currentStaffInfos.length;
        while (i--) {
          if (me.currentStaffInfos[i])
            me.currentStaffInfos[i].forceSectionStartInfo();
        }
      },

      forceStaveStartInfos : function() {
        var me = this, i = me.currentStaffInfos.length;
        while (i--) {
          if (me.currentStaffInfos[i])
            me.currentStaffInfos[i].forceStaveStartInfo();
        }
      },

<span id='MEI2VF-SystemInfo-method-processScoreDef'>      /**
</span>       *
       */
      processScoreDef : function(scoredef) {
        var me = this, i, j, children, systemLeftmar;
        systemLeftmar = $(scoredef).attr('system.leftmar');
        if ( typeof systemLeftmar === 'string') {
          me.setLeftMar(+systemLeftmar);
        }
        children = $(scoredef).children();
        for ( i = 0, j = children.length; i &lt; j; i += 1) {
          me.processScoreDef_child(children[i]);
        }
      },

<span id='MEI2VF-SystemInfo-method-processScoreDef_child'>      /**
</span>       * MEI element &lt;b&gt;scoreDef&lt;/b&gt; may contain (MEI v2.1.0):
       * MEI.cmn: &lt;b&gt;meterSig&lt;/b&gt; &lt;b&gt;meterSigGrp&lt;/b&gt;
       * MEI.harmony: &lt;b&gt;chordTable&lt;/b&gt; MEI.linkalign:
       * &lt;b&gt;timeline&lt;/b&gt; MEI.midi: &lt;b&gt;instrGrp&lt;/b&gt; MEI.shared:
       * &lt;b&gt;keySig&lt;/b&gt; &lt;b&gt;pgFoot&lt;/b&gt; &lt;b&gt;pgFoot2&lt;/b&gt; &lt;b&gt;pgHead&lt;/b&gt;
       * &lt;b&gt;pgHead2&lt;/b&gt; &lt;b&gt;staffGrp&lt;/b&gt; MEI.usersymbols:
       * &lt;b&gt;symbolTable&lt;/b&gt;
       *
       * Supported elements: &lt;b&gt;staffGrp&lt;/b&gt; &lt;b&gt;pgHead&lt;/b&gt;
       *
       * @param {XMLElement} element the scoreDef element to process
       */
      processScoreDef_child : function(element) {
        var me = this;
        switch (element.localName) {
          case 'staffGrp' :
            me.processStaffGrp(element);
            break;
          case 'pgHead' :
            me.processPgHead(element);
            break;
          default :
            throw new m2v.RUNTIME_ERROR('MEI2VF.RERR.NotSupported', 'Element &lt;' + element.localName + '&gt; is not supported in &lt;scoreDef&gt;');
        }
      },

<span id='MEI2VF-SystemInfo-method-processPgHead'>      /**
</span>       *
       */
      processPgHead : function(unused_element) {
        return;
      },

<span id='MEI2VF-SystemInfo-method-processStaffGrp'>      /**
</span>       *
       * @param {XMLElement} staffGrp
       * @param {Boolean} isChild specifies if the staffGrp is a child of another
       *            staffGrp (auto staff connectors only get attached
       *            to the outermost staffGrp elements)
       * @return {Object} the range of the current staff group. Properties:
       *         first_n, last_n
       */
      processStaffGrp : function(staffGrp, isChild) {
        var me = this, range = {};
        $(staffGrp).children().each(function(i, childElement) {
          var childRange = me.processStaffGrp_child(childElement);
          m2v.L('Converter.processStaffGrp() {1}.{a}', 'childRange.first_n: ' + childRange.first_n, ' childRange.last_n: ' + childRange.last_n);
          if (i === 0)
            range.first_n = childRange.first_n;
          range.last_n = childRange.last_n;
        });
        me.setConnectorModels(staffGrp, range, isChild);
        return range;
      },

<span id='MEI2VF-SystemInfo-method-processStaffGrp_child'>      /**
</span>       * MEI element &lt;b&gt;staffGrp&lt;/b&gt; may contain (MEI v2.1.0): MEI.cmn: meterSig
       * meterSigGrp MEI.mensural: mensur proport MEI.midi: instrDef
       * MEI.shared: clef clefGrp keySig label layerDef
       *
       * Supported elements: &lt;b&gt;staffGrp&lt;/b&gt; &lt;b&gt;staffDef&lt;/b&gt;
       *
       * @param {XMLElement} element
       * @return {Object} the range of staffs. Properties: first_n, last_n
       */
      processStaffGrp_child : function(element) {
        var me = this, staff_n;
        switch (element.localName) {
          case 'staffDef' :
            staff_n = me.processStaffDef(element);
            return {
              first_n : staff_n,
              last_n : staff_n
            };
          case 'staffGrp' :
            return me.processStaffGrp(element, true);
          default :
            throw new m2v.RUNTIME_ERROR('MEI2VF.RERR.NotSupported', 'Element &lt;' + element.localName + '&gt; is not supported in &lt;staffGrp&gt;');
        }
      },

<span id='MEI2VF-SystemInfo-method-processStaffDef'>      /**
</span>       * reads a staffDef, writes it to currentStaffInfos
       *
       * @param {XMLElement} staffDef
       * @return {Number} the staff number of the staffDef
       */
      processStaffDef : function(staffDef) {
        var me = this, staff_n, staff_info;
        staff_n = +$(staffDef).attr('n');
        staff_info = me.currentStaffInfos[staff_n];
        if (staff_info) {
          staff_info.updateDef(staffDef);
        } else {
          me.currentStaffInfos[staff_n] = new m2v.StaffInfo(staffDef, true, true, true);
        }
        return staff_n;
      }
    };

    return m2v;

  }(MEI2VF || {}, Vex.Flow, jQuery));
</pre>
</body>
</html>
