<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Converter.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title=""></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/MEI2VF.html">MEI2VF</a></li>
            
                <li><a href="../classes/MEI2VF.Connectors
Handles stave connectors.html">MEI2VF.Connectors
Handles stave connectors</a></li>
            
                <li><a href="../classes/MEI2VF.Converter.html">MEI2VF.Converter</a></li>
            
                <li><a href="../classes/MEI2VF.Directives.html">MEI2VF.Directives</a></li>
            
                <li><a href="../classes/MEI2VF.Dynamics.html">MEI2VF.Dynamics</a></li>
            
                <li><a href="../classes/MEI2VF.EventLink.html">MEI2VF.EventLink</a></li>
            
                <li><a href="../classes/MEI2VF.EventReverence
Represents and event with its xmlid, but if the xmlid is not defined, it
can also hold the timestamp that can be resolved as soon as the context
that
holds the event is established. When the tstamp reference is being
resolved, the xml:id is calculated using the generic function tstamp2id(),
then the
xml:id stored, thus marking that the reference is resolved..html">MEI2VF.EventReverence
Represents and event with its xmlid, but if the xmlid is not defined, it
can also hold the timestamp that can be resolved as soon as the context
that
holds the event is established. When the tstamp reference is being
resolved, the xml:id is calculated using the generic function tstamp2id(),
then the
xml:id stored, thus marking that the reference is resolved.</a></li>
            
                <li><a href="../classes/MEI2VF.Hairpins.html">MEI2VF.Hairpins</a></li>
            
                <li><a href="../classes/MEI2VF.Hyphenation.html">MEI2VF.Hyphenation</a></li>
            
                <li><a href="../classes/MEI2VF.LinkCollection.html">MEI2VF.LinkCollection</a></li>
            
                <li><a href="../classes/MEI2VF.Measure.html">MEI2VF.Measure</a></li>
            
                <li><a href="../classes/MEI2VF.PointerCollection.html">MEI2VF.PointerCollection</a></li>
            
                <li><a href="../classes/MEI2VF.RUNTIME_ERROR.html">MEI2VF.RUNTIME_ERROR</a></li>
            
                <li><a href="../classes/MEI2VF.StaffInfo
Contains the definition and the rendering information (i.e. what
clef modifiers are to be rendered) of a single staff.html">MEI2VF.StaffInfo
Contains the definition and the rendering information (i.e. what
clef modifiers are to be rendered) of a single staff</a></li>
            
                <li><a href="../classes/MEI2VF.StaffVoice.html">MEI2VF.StaffVoice</a></li>
            
                <li><a href="../classes/MEI2VF.StaveVoices
Stores all voices in a given measure along with the respective staff id.
Passes all voices to Vex.Flow.Formatter and calls joinVoices, then draws
all voices..html">MEI2VF.StaveVoices
Stores all voices in a given measure along with the respective staff id.
Passes all voices to Vex.Flow.Formatter and calls joinVoices, then draws
all voices.</a></li>
            
                <li><a href="../classes/MEI2VF.System.html">MEI2VF.System</a></li>
            
                <li><a href="../classes/MEI2VF.SystemInfo
Deals with MEI data provided by scoreDef, staffDef and staffGrp elements and its children.html">MEI2VF.SystemInfo
Deals with MEI data provided by scoreDef, staffDef and staffGrp elements and its children</a></li>
            
                <li><a href="../classes/MEI2VF.Ties.html">MEI2VF.Ties</a></li>
            
                <li><a href="../classes/MEI2VF.Util.html">MEI2VF.Util</a></li>
            
                <li><a href="../classes/MeiLib.html">MeiLib</a></li>
            
                <li><a href="../classes/MeiLib
MeiLib - General purpose JavaScript functions for processing MEI documents..html">MeiLib
MeiLib - General purpose JavaScript functions for processing MEI documents.</a></li>
            
                <li><a href="../classes/MeiLib.Alt
Represents an MEI &lt;b&gt;app&lt;/b&gt; or &lt;b&gt;choice&lt;/b&gt; element..html">MeiLib.Alt
Represents an MEI &lt;b&gt;app&lt;/b&gt; or &lt;b&gt;choice&lt;/b&gt; element.</a></li>
            
                <li><a href="../classes/MeiLib.EventEnumerator
Enumerate over the children events of node (node is a layer or a beam)..html">MeiLib.EventEnumerator
Enumerate over the children events of node (node is a layer or a beam).</a></li>
            
                <li><a href="../classes/MeiLib.MeiDoc
A Rich MEI is an MEI that contain ambiguity represented by Critical Apparatus
(&lt;b&gt;app&lt;/b&gt;, &lt;b&gt;rdg&lt;/b&gt;, etc.), or Editorial Transformation (&lt;b&gt;choice&lt;/b&gt;, &lt;b&gt;corr&lt;/b&gt;, etc.)
elements..html">MeiLib.MeiDoc
A Rich MEI is an MEI that contain ambiguity represented by Critical Apparatus
(&lt;b&gt;app&lt;/b&gt;, &lt;b&gt;rdg&lt;/b&gt;, etc.), or Editorial Transformation (&lt;b&gt;choice&lt;/b&gt;, &lt;b&gt;corr&lt;/b&gt;, etc.)
elements.</a></li>
            
                <li><a href="../classes/MeiLib.RuntimeError.html">MeiLib.RuntimeError</a></li>
            
                <li><a href="../classes/MeiLib.Variant
Represents a &lt;b&gt;lem&lt;/b&gt;, &lt;b&gt;rdg&lt;/b&gt;, &lt;b&gt;sic&lt;/b&gt; or &lt;b&gt;corr&lt;/b&gt; element..html">MeiLib.Variant
Represents a &lt;b&gt;lem&lt;/b&gt;, &lt;b&gt;rdg&lt;/b&gt;, &lt;b&gt;sic&lt;/b&gt; or &lt;b&gt;corr&lt;/b&gt; element.</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: Converter.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/*
 * MEItoVexFlow
 *
 * Author: Richard Lewis Contributors: Zoltan Komives, Raffaele Viglianti
 *
 * See README for details of this library
 *
 * Copyright Â© 2012, 2013 Richard Lewis, Raffaele Viglianti, Zoltan Komives,
 * University of Maryland
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

var MEI2VF = ( function(m2v, VF, $, undefined) {

    /**
     * Converts an MEI XML document / document fragment to VexFlow objects and
     * optionally renders it using Raphael or HTML5 Canvas.
     *
     * Usage:
     *
     * - Either pass a config object to the constructor function or (if no config
     * object has been passed) call {@link #initConfig} after construction.
     * - Call {@link #process} to process an MEI XML document
     * - Call {@link #draw} to draw the processed VexFlow objects to a canvas

     * @class MEI2VF.Converter
     *
     * @constructor
     * @param {Object} [config]
     * @chainable
     * @return {MEI2VF.Converter} this
     */
    m2v.Converter = function(config) {
      if (config)
        this.initConfig(config);
      return this;
    };

    m2v.Converter.prototype = {

      // TODO calculate now, that should not be too expensive
      // currently fixed
      HALF_LINE_DISTANCE : 5, // VF.Staff.spacing_between_lines_px / 2;

      BOTTOM : VF.Annotation.VerticalJustify.BOTTOM,

      defaults : {
        /**
         * @cfg {Number} page_width The width of the page
         */
        page_width : 800,
        /**
         * @cfg {Number} page_margin_top The top page margin
         */
        page_margin_top : 60,
        /**
         * @cfg {Number} page_margin_left The left page margin
         */
        page_margin_left : 20,
        /**
         * @cfg {Number} page_margin_right The right page margin
         */
        page_margin_right : 20,
        /**
         * @cfg {Number} systemSpacing The spacing between two staff
         * systems
         */
        systemSpacing : 90,
        /**
         * @cfg {Number} staveSpacing The default spacing between two staffs
         * within a system; overridden by the spacing attribute of a staffDef
         * element in the MEI code
         */
        staveSpacing : 60,
        /**
         * @cfg {Boolean} autoStaveConnectorLine Specifies if a stave connector
         * line is drawn on the left of systems by default; if set to true, the
         * auto line will not appear when staffDef/@symbol=&quot;none&quot; is set for the
         * outermost staffDef element
         */
        autoStaveConnectorLine : true,
        /**
         * @cfg {&quot;full&quot;/&quot;abbr&quot;/null} labelMode Specifies the way voice labels are
         * added
         * to staves. Values:
         *
         * - &#x27;full&#x27;: renders full labels in the first system, abbreviated labels
         * in all following systems
         * - &#x27;abbr&#x27;: only render abbreviated labels
         * - null or undefined: renders no labels
         */
        labelMode : null, // &#x27;full&#x27;,
        /**
         * @cfg {Number} maxHyphenDistance The maximum distance (in pixels)
         * between two hyphens in the lyrics lines
         */
        maxHyphenDistance : 75,
        //sectionsOnNewLine : false, // TODO: add feature

        // TODO check compatibility with RAPHAEL!
        /**
         * @cfg {Object} lyricsFont The font used for rendering lyrics (and
         * hyphens)
         * @cfg {String} lyricsFont.family the font family
         * @cfg {Number} lyricsFont.size the font size
         *
         * NB the weight properties can be used to specify style, weight
         * or both (space separated); some of the objects are passed directly
         * to vexFlow (which requires the name &#x27;weight&#x27;), so the name is
         * &#x27;weight&#x27;
         */
        lyricsFont : {
          family : &#x27;Times&#x27;,
          size : 15
        },
        /**
         * @cfg {Object} annotFont the font used for annotations (for example,
         * &#x27;pizz.&#x27;)
         * @cfg {String} annotFont.family the font family
         * @cfg {Number} annotFont.size the font size
         * @cfg {String} annotFont.weight the font weight
         */
        annotFont : {
          family : &#x27;Times&#x27;,
          size : 15,
          weight : &#x27;Italic&#x27;
        },
        /**
         * @cfg {Object} dynamFont the font used for dynamics
         * @cfg {String} dynamFont.family the font family
         * @cfg {Number} dynamFont.size the font size
         * @cfg {String} dynamFont.weight the font weight
         */
        dynamFont : {
          family : &#x27;Times&#x27;,
          size : 18,
          weight : &#x27;bold italic&#x27;
        },
        /**
         * @cfg {Object} tempoFont The tempo font
         * @cfg {String} tempoFont.family the font family
         * @cfg {Number} tempoFont.size the font size
         * @cfg {String} tempoFont.weight the font weight
         */
        tempoFont : {
          family : &quot;Times&quot;,
          size : 17,
          weight : &quot;bold&quot;
        },
        /**
         * @cfg {Object} staff The staff config object passed to each
         * Vex.Flow.Staff
         */
        staff : {
          vertical_bar_width : 20, // 10 // Width around vertical bar end-marker
          top_text_position : 1.5, // 1 // in staff lines
          bottom_text_position : 7.5
        }
      },

      // TODO add setters (and getters?) for single config items / groups
      /**
       * initializes the Converter
       * @method initConfig
       * @param {Object} config A config object (optional)
       * @chainable
       * @return {MEI2VF.Converter} this
       */
      initConfig : function(config) {
        var me = this;
        me.cfg = $.extend(true, {}, me.defaults, config);
        /**
         * an instance of MEI2VF.SystemInfo dealing with the system and staff
         * info derived from
         * the MEI data
         * @property {MEI2VF.SystemInfo} systemInfo
         */
        me.systemInfo = new m2v.SystemInfo();

        // TODO see if the values of this property should better be calculated
        // in the viewer object
        /**
         * The print space coordinates calculated from the page config.
         * @property {Object} printSpace
         * @property {Number} printSpace.top
         * @property {Number} printSpace.left
         * @property {Number} printSpace.right
         * @property {Number} printSpace.width
         */
        me.printSpace = {
          // substract four line distances (40px) from page_margin_top in order
          // to compensate VexFlow&#x27;s default top spacing / allow specifying
          // absolute
          // values
          top : me.cfg.page_margin_top - 40,
          left : me.cfg.page_margin_left,
          right : me.cfg.page_width - me.cfg.page_margin_right,
          width : Math.floor(me.cfg.page_width - me.cfg.page_margin_right - me.cfg.page_margin_left) - 1
        };
        return me;

      },

      // TODO instead of creating new objects each time on reset, call reset functions in the generated objects
      /**
       * Resets all data. Called by {@link #process}.
       * @method reset
       * @chainable
       * @return {MEI2VF.Converter} this
       */
      reset : function() {
        var me = this;
        me.systemInfo.init(me.cfg, me.printSpace);
        /**
         * @property {} unresolvedTStamp2
         */
        me.unresolvedTStamp2 = [];
        /**
         * Contains all {@link MEI2VF.System} objects
         * @property {MEI2VF.System[]} systems
         */

        me.systems = [];
        /**
         * Contains all
         * Vex.Flow.Stave objects. Addressing scheme:
         * [measure_n][staff_n]
         * @property {Vex.Flow.Stave[][]} allVexMeasureStaffs
         */
        me.allVexMeasureStaffs = [];
        /**
         * Contains all Vex.Flow.Beam objects. Data is just pushed in
         * and later processed as a whole, so the array index is
         * irrelevant.
         * @property {Vex.Flow.Beam[]} allBeams
         */
        me.allBeams = [];
        /**
         * an instance of MEI2VF.Dynamics dealing with and storing all dynamics
         * found in the MEI document
         * @property {MEI2VF.Dynamics} dynamics
         */
        me.dynamics = new m2v.Dynamics(me.systemInfo, me.cfg.dynamFont);
        /**
         * an instance of MEI2VF.Directives dealing with and storing all
         * directives found in the MEI document
         * @property {MEI2VF.Directives} directives
         */
        me.directives = new m2v.Directives(me.systemInfo, me.cfg.annotFont);
        /**
         * an instance of MEI2VF.Ties dealing with and storing all ties found in
         * the MEI document
         * @property {MEI2VF.Ties} ties
         */
        me.ties = new m2v.Ties(me.systemInfo, me.unresolvedTStamp2);
        /**
         * an instance of MEI2VF.Ties dealing with and storing all slurs found in
         * the MEI document
         * @property {MEI2VF.Ties} slurs
         */
        me.slurs = new m2v.Ties(me.systemInfo, me.unresolvedTStamp2);
        /**
         * an instance of MEI2VF.Hairpins dealing with and storing all hairpins
         * found in the MEI document
         * @property {MEI2VF.Hairpins} hairpins
         */
        me.hairpins = new m2v.Hairpins(me.systemInfo, me.unresolvedTStamp2);
        /**
         * an instance of MEI2VF.Hyphenation dealing with and storing all lyrics
         * hyphens found in the MEI document
         * @property {MEI2VF.Hyphenation} hyphenation
         */
        me.hyphenation = new m2v.Hyphenation(me.cfg.lyricsFont, me.printSpace.right, me.cfg.maxHyphenDistance);
        /**
         * contains all note-like objects in the current MEI document, accessible
         * by their xml:id
         * @property {Object} notes_by_id
         * @property {XMLElement} notes_by_id.meiNote the XML Element of the note
         * @property {Vex.Flow.StaveNote} notes_by_id.vexNote the VexFlow note
         * object
         */
        me.notes_by_id = {};
        /**
         * the number of the current system
         * @property {Number} currentSystem_n
         */
        me.currentSystem_n = 0;
        /**
         * indicates if a system break is currently to be processed
         * @property {Boolean} pendingSystemBreak
         */
        me.pendingSystemBreak = false;
        /**
         * indicates if a system break is currently to be processed
         * @property {Boolean} pendingSectionBreak
         */
        me.pendingSectionBreak = true;
        /**
         * Contains information about the
         * volta type of the current staff. Properties:
         *
         * -  &#x60;start&#x60; {String} indicates the number to render to the volta. When
         * falsy, it is assumed that the volta does not start in the current
         * measure
         * -  &#x60;end&#x60; {Boolean} indicates if there is a volta end in the current
         * measure
         *
         * If null, no volta is rendered
         * @property {Object} currentVoltaType
         */
        me.currentVoltaType = null;
        return me;
      },

      /**
       * Calls {@link #reset} and then processes the specified MEI document or
       * document fragment. The generated objects can
       * be processed further or drawn immediately to a canvas via {@link #draw}.
       * @method process
       * @chainable
       * @param {XMLDocument} xmlDoc the XML document
       * @return {MEI2VF.Converter} this
       */
      process : function(xmlDoc) {
        var me = this;
        me.reset();
        me.systemInfo.processScoreDef($(xmlDoc).find(&#x27;scoreDef&#x27;)[0]);
        me.processSections(xmlDoc);
        me.directives.createVexFromInfos(me.notes_by_id);
        me.dynamics.createVexFromInfos(me.notes_by_id);
        me.ties.createVexFromInfos(me.notes_by_id);
        me.slurs.createVexFromInfos(me.notes_by_id);
        me.hairpins.createVexFromInfos(me.notes_by_id);
        return me;
      },

      /**
       * Draws the internal data objects to a canvas
       * @method draw
       * @chainable
       * @param ctx The canvas context
       * @return {MEI2VF.Converter} this
       */
      draw : function(ctx) {
        var me = this;
        me.drawSystems(ctx);
        me.drawVexBeams(me.allBeams, ctx);
        me.ties.setContext(ctx).draw();
        me.slurs.setContext(ctx).draw();
        me.hairpins.setContext(ctx).draw();
        me.hyphenation.setContext(ctx).draw();
        return me;
      },

      /**
       * assigns an external function for processing pgHead elements. By default,
       * pgHead elements are ignored in MEI2VF.
       * @method setPgHeadProcessor
       * @param {Function} fn the callback function. Parameter: element
       */
      setPgHeadProcessor : function(fn) {
        this.systemInfo.processPgHead = fn;
      },

      /**
       * assigns an external function for processing anchoredText elements. By
       * default, anchoredText elements are ignored in MEI2VF.
       * @method setAnchoredTextProcessor
       * @param {Function} fn the callback function. Parameter: element
       */
      setAnchoredTextProcessor : function(staffFn, layerFn) {
        if (staffFn) {
          this.processAnchoredStaffText = staffFn;
        };
        if (layerFn) {
          this.processAnchoredLayerText = layerFn;
        }
      },

      /**
       * Returns the width and the height of the area that contains all drawn
       * staves as per the last processing.
       *
       * @method getStaffArea
       * @return {Object} the width and height of the area that contains all
       * staves.
       * Properties: width, height
       */
      getStaffArea : function() {
        var width, height, i;
        height = this.systemInfo.getCurrentLowestY();
        var allVexMeasureStaffs = this.getAllVexMeasureStaffs();
        var i, k, max_start_x, area_width, staff;
        i = allVexMeasureStaffs.length;
        area_width = 0;
        while (i--) {
          if (allVexMeasureStaffs[i]) {
            max_start_x = 0;
            // get maximum start_x of all staffs in measure
            k = allVexMeasureStaffs[i].length;
            while (k--) {
              staff = allVexMeasureStaffs[i][k];
              if (staff)
                max_start_x = Math.max(max_start_x, staff.getNoteStartX());
            }
            k = allVexMeasureStaffs[i].length;
            while (k--) {
              // get maximum width of all staffs in measure
              staff = allVexMeasureStaffs[i][k];
              if (staff) {
                area_width = Math.max(area_width, max_start_x + staff.getWidth());
              }
            }
          }
        }
        return {
          width : area_width,
          height : height
        };
      },

      /**
       * returns a 2d array of all Vex.Flow.Stave objects, arranged by
       * [measure_n][staff_n]
       * @method getAllVexMeasureStaffs
       * @return {Vex.Flow.Stave[][]} see {@link #allVexMeasureStaffs}
       */
      getAllVexMeasureStaffs : function() {
        return this.allVexMeasureStaffs;
      },

      /**
       * returns all systems created when processing the MEI document
       * @method getSystems
       * @return {MEI2VF.System[]}
       */
      getSystems : function() {
        return this.systems;
      },

      /**
       * returns all note-like objects created when processing the MEI document
       * @method getNotes
       * @return {Object} for the object properties, see {@link #notes_by_id}
       */
      getNotes : function() {
        return this.notes_by_id;
      },

      /**
       * creates in initializes a new {@link MEI2VF.System} and updates the staff
       * modifier infos
       * @method createNewSystem
       */
      createNewSystem : function() {
        var me = this, system, coords;

        m2v.L(&#x27;Converter.createNewSystem()&#x27;, &#x27;{enter}&#x27;);

        me.pendingSystemBreak = false;
        me.currentSystem_n += 1;

        coords = {
          x : me.printSpace.left,
          y : (me.currentSystem_n === 1) ? me.printSpace.top : me.systemInfo.getCurrentLowestY() + me.cfg.systemSpacing,
          w : me.printSpace.width
        };

        system = new m2v.System({
          leftMar : me.systemInfo.getLeftMar(),
          coords : coords,
          staffYs : me.systemInfo.getYs(coords.y),
          labels : me.getStaffLabels()
        });

        if (me.pendingSectionBreak) {
          me.pendingSectionBreak = false;
          me.systemInfo.forceSectionStartInfos();
        } else {
          me.systemInfo.forceStaveStartInfos();
        }

        me.hyphenation.addLineBreaks(me.systemInfo.getAllStaffInfos(), {
          system : system
        });

        me.systems[me.currentSystem_n] = system;
        return system;
      },

      // TODO: add rule: if an ending is followed by another ending, add
      // space on the right (or choose a VexFlow parameter accordingly),
      // otherwise don&#x27;t add space
      /**
       * @method processSections
       */
      processSections : function(xmlDoc) {
        var me = this;
        $(xmlDoc).find(&#x27;section, ending&#x27;).each(function() {
          if (this.localName === &#x27;ending&#x27;) {
            me.processEnding(this);
          } else {
            me.processSection(this);
          }
        });
      },

      /**
       *@method processSection
       */
      processSection : function(element) {
        var me = this, i, j, sectionChildren = $(element).children();
        for ( i = 0, j = sectionChildren.length; i &lt; j; i += 1) {
          me.processSectionChild(sectionChildren[i]);
        }
      },

      /**
       * @method processEnding
       */
      processEnding : function(element) {
        var me = this, i, j, sectionChildren = $(element).children();
        for ( i = 0, j = sectionChildren.length; i &lt; j; i += 1) {
          me.currentVoltaType = {};
          if (i === 0)
            me.currentVoltaType.start = $(element).attr(&#x27;n&#x27;);
          if (i === j - 1)
            me.currentVoltaType.end = true;
          me.processSectionChild(sectionChildren[i]);
        }
        me.currentVoltaType = null;
      },

      /**
       * MEI element &lt;b&gt;section&lt;/b&gt; may contain (MEI v2.1.0): MEI.cmn: measure
       * MEI.critapp: app MEI.edittrans: add choice corr damage del gap
       * handShift orig reg restore sic subst supplied unclear MEI.shared:
       * annot ending expansion pb sb scoreDef section staff staffDef
       * MEI.text: div MEI.usersymbols: anchoredText curve line symbol
       *
       * Supported elements: &lt;b&gt;measure&lt;/b&gt; &lt;b&gt;scoreDef&lt;/b&gt; &lt;b&gt;staffDef&lt;/b&gt;
       * &lt;b&gt;sb&lt;/b&gt;
       *  @method processSectionChild
       */
      processSectionChild : function(element) {
        var me = this;
        switch (element.localName) {
          case &#x27;measure&#x27; :
            me.processMeasure(element);
            break;
          case &#x27;scoreDef&#x27; :
            me.systemInfo.processScoreDef(element);
            break;
          case &#x27;staffDef&#x27; :
            me.systemInfo.processStaffDef(element);
            break;
          case &#x27;sb&#x27; :
            me.setPendingSystemBreak(element);
            break;
          default :
            throw new m2v.RUNTIME_ERROR(&#x27;MEI2VF.RERR.NotSupported&#x27;, &#x27;Element &lt;&#x27; + element.localName + &#x27;&gt; is not supported in &lt;section&gt;&#x27;);
        }
      },

      /**
       * sets the property {@link #pendingSystemBreak} to &#x60;true&#x60;. When true, a
       * new system will be initialized when {@link #processMeasure} is called
       * the next time.
       *  @method setPendingSystemBreak
       */
      setPendingSystemBreak : function() {
        this.pendingSystemBreak = true;
      },

      // TODO extract function for measure_child (see the staffDef functions)!?
      /**
       * Processes a MEI measure element and calls functions to process a
       * selection of ancestors: .//staff, ./slur, ./tie, ./hairpin, .//tempo
       *  @method processMeasure
       * @param {XMLElement} element the MEI measure element
       */
      processMeasure : function(element) {
        var me = this, measure_n, atSystemStart, left_barline, right_barline, atSystemTop = true, system, system_n;

        if (me.pendingSectionBreak || me.pendingSystemBreak) {
          system_n = me.systems.length;
          system = me.createNewSystem();
          atSystemStart = true;
        } else {
          system_n = me.systems.length - 1;
          system = me.systems[system_n];
          atSystemStart = false;
        }

        m2v.L(&#x27;Converter.processMeasure()&#x27;, &#x27;{enter}&#x27;);

        measure_n = +element.getAttribute(&#x27;n&#x27;);
        left_barline = element.getAttribute(&#x27;left&#x27;);
        right_barline = element.getAttribute(&#x27;right&#x27;);

        var staffElements = [], dirElements = [], slurElements = [], tieElements = [], hairpinElements = [], tempoElements = [], dynamElements = [];

        $(element).find(&#x27;*&#x27;).each(function() {
          switch (this.localName) {
            case &#x27;staff&#x27;:
              staffElements.push(this);
              break;
            case &#x27;dir&#x27;:
              dirElements.push(this);
              break;
            case &#x27;tie&#x27;:
              tieElements.push(this);
              break;
            case &#x27;slur&#x27;:
              slurElements.push(this);
              break;
            case &#x27;hairpin&#x27;:
              hairpinElements.push(this);
              break;
            case &#x27;tempo&#x27;:
              tempoElements.push(this);
              break;
            case &#x27;dynam&#x27;:
              dynamElements.push(this);
              break;
            default:
              break;
          }
        });

        // references to the staffs will be stored in two places:
        // 1) in the measure objects
        // 2) in this.allVexMeasureStaffs
        var staffs = [];
        me.allVexMeasureStaffs[measure_n] = staffs;

        var currentStaveVoices = new m2v.StaveVoices();

        // TODO create all staff objects before processing the voices so a
        // reference to any staff object in the current measure can be set to the
        // note-like objects (this is necessary when the attribute staff=n is
        // used, for example)
        $.each(staffElements, function() {
          me.processStaffInMeasure(system, staffs, this, measure_n, left_barline, right_barline, currentStaveVoices, atSystemTop);
          atSystemTop = false;
        });

        me.directives.createInfos(dirElements, element);
        me.dynamics.createInfos(dynamElements, element);
        me.ties.createInfos(tieElements, element, me.systemInfo);
        me.slurs.createInfos(slurElements, element, me.systemInfo);
        me.hairpins.createInfos(hairpinElements, element, me.systemInfo);

        system.addMeasure(new m2v.Measure({
          element : element,
          n : measure_n,
          staffs : staffs,
          voices : currentStaveVoices,
          startConnectorCfg : (atSystemStart) ? {
            labelMode : me.cfg.labelMode,
            models : me.systemInfo.startConnectorInfos,
            staffs : staffs,
            system_n : me.currentSystem_n
          } : null,
          inlineConnectorCfg : {
            models : me.systemInfo.inlineConnectorInfos,
            staffs : staffs,
            barline_l : left_barline,
            barline_r : right_barline
          },
          tempoElements : tempoElements,
          tempoFont : me.cfg.tempoFont
        }));
      },

      /**
       * Processes a single stave in a measure
       *
       * @method processStaffInMeasure
       * @param {MEI2VF.System} system the current system
       * @param {Array} staffs
       * @param {XMLElement} staff_element the MEI staff element
       * @param {Number} measure_n the measure number
       * @param {String} left_barline the left barline
       * @param {String} right_barline the right barline
       * @param {MEI2VF.StaveVoices} currentStaveVoices The current MEI2VF
       * StaveVoices object
       * @param {Boolean} atSystemTop indicates if the current stave is the first
       * stave in its system
       */
      processStaffInMeasure : function(system, staffs, staff_element, measure_n, left_barline, right_barline, currentStaveVoices, atSystemTop) {
        var me = this, staff, staff_n, readEvents, layer_events;

        staff_n = +$(staff_element).attr(&#x27;n&#x27;);
        if (!staff_n) {
          throw new m2v.RUNTIME_ERROR(&#x27;MEI2VF.RERR.BadArgument&#x27;, &#x27;Cannot render staff without attribute &quot;n&quot;.&#x27;);
        }

        staff = me.createVexStaff(system.getStaffYs()[staff_n]);

        me.addStaffModifiers(staff, staff_n, left_barline, right_barline, atSystemTop);

        staffs[staff_n] = staff;

        $(staff_element).children(&#x27;anchoredText&#x27;).each(function() {
          me.processAnchoredStaffText(this, staff);
        });

        readEvents = function() {
          var event = me.processNoteLikeElement(this, staff, staff_n);
          // return event.vexNote;
          return event.vexNote || event;
        };

        $(staff_element).find(&#x27;layer&#x27;).each(function() {
          me.resolveUnresolvedTimestamps(this, staff_n, measure_n);
          layer_events = $(this).children().map(readEvents).get();
          currentStaveVoices.addVoice(me.createVexVoice(layer_events, staff_n), staff_n);
        });

      },

      /**
       * Creates a new Vex.Flow.Stave object at the specified y coordinate. This
       * method sets fixed x coordinates, which will later be substituted in
       * {@link MEI2VF.System#format} - the Vex.Flow.Stave
       * objects must be initialized with some x measurements, but the real
       * values depend on values only available after modifiers, voices etc
       * have been added.
       *
       *  @method createVexStaff
       * @param {Number} y the y coordinate of the staff
       * @return {Vex.Flow.Stave} The initialized stave object
       */
      createVexStaff : function(y) {
        var me = this, staff;
        staff = new VF.Stave();
        staff.init(0, y, 1000, me.cfg.staff);
        // temporary; (due to a bug?) in VexFlow, bottom_text_position does
        // not work when it&#x27;s passed in the config object
        staff.options.bottom_text_position = me.cfg.staff.bottom_text_position;
        return staff;
      },

      /**
       * Adds staff modifiers (bar lines, clef, time signature, key signature,
       * volta) to a Vex.Flow.Staff.
       *
       *  @method addStaffModifiers
       * @param {Vex.Flow.Stave} staff The stave object
       * @param {Number} staff_n the staff number
       * @param {String} left_barline the left barline
       * @param {String} right_barline the right barline
       * @param {Boolean} atSystemTop indicates if the current stave is the first
       * stave in its system
       */
      addStaffModifiers : function(staff, staff_n, left_barline, right_barline, atSystemTop) {
        var me = this, currentStaffInfo;

        currentStaffInfo = me.systemInfo.getStaffInfo(staff_n);

        if (currentStaffInfo.showClefCheck()) {
          staff.clefIndex = 2;
          staff.addClef(currentStaffInfo.getClef());
        }
        if (currentStaffInfo.showKeysigCheck()) {
          staff.keySigIndex = staff.clefIndex + 1 || 2;
          staff.addKeySignature(currentStaffInfo.getKeySpec());

        }
        if (currentStaffInfo.showTimesigCheck()) {
          staff.timeSigIndex = staff.keySigIndex + 1 || staff.clefIndex + 1 || 2;
          staff.addTimeSignature(currentStaffInfo.getTimeSig());
        }

        staff.setBegBarType( left_barline ? m2v.tables.barlines[left_barline] : VF.Barline.type.NONE);
        if (right_barline)
          staff.setEndBarType(m2v.tables.barlines[right_barline]);

        if (atSystemTop &amp;&amp; me.currentVoltaType) {
          me.addStaffVolta(staff);
        }
      },

      /**
       * Adds a volta to a staff. Currently not working due to the reworking of
       * the measure width calulation (27/4/2014)
       *  @method addStaffVolta
       * @experimental
       */
      addStaffVolta : function(staff) {
        var volta = this.currentVoltaType;
        if (volta.start)
          staff.setVoltaType(Vex.Flow.Volta.type.BEGIN, volta.start + &#x27;.&#x27;, 30, 0);
        if (volta.end)
          staff.setVoltaType(Vex.Flow.Volta.type.END, &quot;&quot;, 30, 0);
        if (!volta.start &amp;&amp; !volta.end)
          staff.setVoltaType(Vex.Flow.Volta.type.MID, &quot;&quot;, 30, 0);
      },

      /**
       * @method getStaffLabels
       */
      getStaffLabels : function() {
        var me = this, labels, i, infos, labelType;
        labels = {};
        if (!me.cfg.labelMode) {
          return labels;
        }
        labelType = (me.cfg.labelMode === &#x27;full&#x27; &amp;&amp; me.currentSystem_n === 1) ? &#x27;label&#x27; : &#x27;labelAbbr&#x27;;
        infos = me.systemInfo.getAllStaffInfos();
        i = infos.length;
        while (i--) {
          if (infos[i]) {
            labels[i] = infos[i][labelType];
          }
        }
        return labels;
      },

      /**
       * Creates a new Vex.Flow.Voice
       *  @method createVexVoice
       * @param {Array} voice_contents The contents of the voice, an array of
       * tickables
       * @param {Number} staff_n The number of the enclosing staff element
       * return {Vex.Flow.Voice}
       */
      createVexVoice : function(voice_contents, staff_n) {
        var me = this, voice, meter;
        if (!$.isArray(voice_contents)) {
          throw new m2v.RUNTIME_ERROR(&#x27;BadArguments&#x27;, &#x27;me.createVexVoice() voice_contents argument must be an array.&#x27;);
        }
        meter = me.systemInfo.getStaffInfo(staff_n).meter;
        voice = new VF.Voice({
          num_beats : meter.count,
          beat_value : meter.unit,
          resolution : VF.RESOLUTION
        });
        voice.setStrict(false);
        voice.addTickables(voice_contents);
        return voice;
      },

      /**
       * @method resolveUnresolvedTimestamps
       */
      resolveUnresolvedTimestamps : function(layer, staff_n, measure_n) {
        var me = this, refLocationIndex;
        // check if there&#x27;s an unresolved TStamp2 reference to this location
        // (measure, staff, layer):
        if (isNaN(measure_n))
          throw new m2v.RUNTIME_ERROR(&#x27;MEI2VF.RERR.extract_events&#x27;, &#x27;&lt;measure&gt; must have @n specified&#x27;);
        staff_n = staff_n || 1;
        refLocationIndex = measure_n + &#x27;:&#x27; + staff_n + &#x27;:&#x27; + ($(layer).attr(&#x27;n&#x27;) || &#x27;1&#x27;);
        if (me.unresolvedTStamp2[refLocationIndex]) {
          $(me.unresolvedTStamp2[refLocationIndex]).each(function(i) {
            this.setContext({
              layer : layer,
              meter : me.systemInfo.getStaffInfo(staff_n).meter
            });
            // TODO: remove eventLink from the list
            me.unresolvedTStamp2[refLocationIndex][i] = null;
          });
          // at this point all references should be supplied with context.
          me.unresolvedTStamp2[refLocationIndex] = null;
        }
      },

      /**
       * processes a note like element by calling the adequate processing
       * function
       *  @method processNoteLikeElement
       * @param {XMLElement} element the element to process
       * @param {} staff
       * @param {Number} staff_n the number of the staff as given in the MEI
       * document
       */
      processNoteLikeElement : function(element, staff, staff_n) {
        var me = this;
        switch (element.localName) {
          case &#x27;rest&#x27; :
            return me.processRest(element, staff, staff_n);
          case &#x27;mRest&#x27; :
            return me.processmRest(element, staff, staff_n);
          case &#x27;space&#x27; :
            return me.processSpace(element, staff, staff_n);
          case &#x27;note&#x27; :
            return me.processNote(element, staff, staff_n);
          case &#x27;beam&#x27; :
            return me.processBeam(element, staff, staff_n);
          case &#x27;chord&#x27; :
            return me.processChord(element, staff, staff_n);
          case &#x27;anchoredText&#x27; :
            return me.processAnchoredLayerText(element, staff, staff_n);
          default :
            throw new m2v.RUNTIME_ERROR(&#x27;BadArguments&#x27;, &#x27;Rendering of element &quot;&#x27; + element.localName + &#x27;&quot; is not supported.&#x27;);
        }
      },

      /**
       * @method processAnchoredStaffText
       */
      processAnchoredStaffText : function() {
        // override
        return;
      },

      /**
       * @method processAnchoredLayerText
       */
      processAnchoredLayerText : function() {
        // TODO
        return;
      },

      /**
       * @method processNote
       */
      processNote : function(element, staff, staff_n) {
        var me = this, dots, mei_accid, mei_ho, pname, oct, xml_id, mei_tie, mei_slur, mei_staff_n, i, atts, note_opts, note;

        atts = m2v.Util.attsToObj(element);

        dots = +atts.dots;
        mei_accid = atts.accid;
        mei_ho = atts.ho;
        pname = atts.pname;
        oct = atts.oct;
        mei_tie = atts.tie;
        mei_slur = atts.slur;
        mei_staff_n = +atts.staff || staff_n;

        xml_id = atts[&#x27;xml:id&#x27;];
        // If xml:id is missing, create it
        if (!xml_id) {
          xml_id = MeiLib.createPseudoUUID();
          $(element).attr(&#x27;xml:id&#x27;, xml_id);
        }

        try {

          note_opts = {
            keys : [me.processAttsPitch(element)],
            clef : me.systemInfo.getClef(staff_n),
            duration : me.processAttsDuration(element)
          };

          me.setStemDir(element, note_opts);
          note = new VF.StaveNote(note_opts);

          if (mei_staff_n === staff_n) {
            note.setStave(staff);
          } else {
            var otherStaff = me.allVexMeasureStaffs[me.allVexMeasureStaffs.length - 1][mei_staff_n];
            if (otherStaff) {
              // TODO: the note is correctly assigned to the new staff
              // here, but
              // in the end it has the old staff assigned to it -&gt; fix
              // that!
              // REASON PROBABLY: all notes get assigned to the old
              // staff when
              // the voices are drawn in StaveVoices.js
              // ALSO: Vex.Flow.Voice seems to assign all voice
              // tickables to only
              // one staff
              // n = note;
              note.setStave(otherStaff);
            } else {
              throw new m2v.RUNTIME_ERROR(&#x27;Error&#x27;, &#x27;Note has staff attribute &quot;&#x27; + mei_staff_n + &#x27;&quot;, but the staff does not exist.&#x27;);
            }
          }

          me.processSyllables(note, element, staff_n);

          try {
            for ( i = 0; i &lt; dots; i += 1) {
              note.addDotToAll();
            }
          } catch (e) {
            throw new m2v.RUNTIME_ERROR(&#x27;BadArguments&#x27;, &#x27;A problem occurred processing the dots of &lt;note&gt;: &#x27; + m2v.Util.attsToString(element));
          }

          if (mei_accid)
            me.processAttrAccid(mei_accid, note, 0);
          if (mei_ho)
            me.processAttrHo(mei_ho, note);

          $.each($(element).find(&#x27;artic&#x27;), function() {
            me.addArticulation(note, this);
          });
          if (atts.fermata) {
            me.addFermata(note, atts.fermata);
          }

          // FIXME For now, we&#x27;ll remove any child nodes of &lt;note&gt;
          $.each($(element).children(), function() {
            $(this).remove();
          });

          // Build a note object that keeps the xml:id

          if (!pname)
            throw new m2v.RUNTIME_ERROR(&#x27;MEI2VF.RERR.BadArguments&#x27;, &#x27;mei:note must have pname attribute&#x27;);
          if (!oct)
            throw new m2v.RUNTIME_ERROR(&#x27;MEI2VF.RERR.BadArguments&#x27;, &#x27;mei:note must have oct attribute&#x27;);

          if (mei_tie)
            me.processAttrTie(mei_tie, xml_id, pname, oct);
          if (mei_slur)
            me.processAttrSlur(mei_slur, xml_id);

          me.notes_by_id[xml_id] = {
            meiNote : element,
            vexNote : note,
            system : me.currentSystem_n
          };

          // return note object
          return {
            vexNote : note,
            id : xml_id
          };

        } catch (e1) {
          throw new m2v.RUNTIME_ERROR(&#x27;BadArguments&#x27;, &#x27;A problem occurred processing the &lt;note&gt;: &#x27; + m2v.Util.attsToString(element) + &#x27;\nORIGINAL ERROR MESSAGE: &#x27; + e1.toString());
        }
      },

      // TODO add support for features found in me.processNote (annot etc.)
      // extract functions!?
      /**
       * @method processChord
       */
      processChord : function(element, staff, staff_n) {
        var me = this, i, j, hasDots, $children, keys = [], duration, durations = [], durAtt, xml_id, mei_slur, mei_ho, chord, chord_opts, atts, note_atts;

        $children = $(element).children();

        atts = m2v.Util.attsToObj(element);
        durAtt = atts.dur;
        // mei_tie = atts.tie;
        // mei_slur = atts.slur;

        xml_id = atts[&#x27;xml:id&#x27;];
        // If xml:id is missing, create it
        if (!xml_id) {
          xml_id = MeiLib.createPseudoUUID();
          $(element).attr(&#x27;xml:id&#x27;, xml_id);
        }

        hasDots = !!$(element).attr(&#x27;dots&#x27;);

        try {
          if (durAtt) {
            duration = me.translateDuration(+durAtt);
          } else {
            for ( i = 0, j = $children.length; i &lt; j; i += 1) {
              durations.push(+$children[i].getAttribute(&#x27;dur&#x27;));
            }
            duration = me.translateDuration(Math.max.apply(Math, durations));
          }

          for ( i = 0, j = $children.length; i &lt; j; i += 1) {
            keys.push(me.processAttsPitch($children[i]));
            // dots.push(+$children[i].getAttribute(&#x27;dots&#x27;));
            if ($children[i].getAttribute(&#x27;dots&#x27;) === &#x27;1&#x27;)
              hasDots = true;
          }

          if (hasDots)
            duration += &#x27;d&#x27;;

          chord_opts = {
            keys : keys,
            clef : me.systemInfo.getClef(staff_n),
            duration : duration
          };

          me.setStemDir(element, chord_opts);
          chord = new VF.StaveNote(chord_opts);
          chord.setStave(staff);

          var allNoteIndices = [];

          $children.each(function(i) {
            me.processNoteInChord(i, this, element, chord);
            allNoteIndices.push(i);
          });

          if (hasDots) {
            chord.addDotToAll();
          }
          if (atts.ho) {
            me.processAttrHo(atts.ho, chord);
          }
          if (atts.fermata) {
            me.addFermata(chord, atts.fermata);
          }

          // TODO add support for chord/@tie and chord/@slur

          me.notes_by_id[xml_id] = {
            meiNote : element,
            vexNote : chord,
            index : allNoteIndices,
            system : me.currentSystem_n
          };

          return {
            vexNote : chord,
            id : xml_id
          };
        } catch (e) {
          throw new m2v.RUNTIME_ERROR(&#x27;BadArguments&#x27;, &#x27;A problem occurred processing the &lt;chord&gt;:&#x27; + e.toString());
          // &#x27;A problem occurred processing the &lt;chord&gt;: &#x27; +
          // JSON.stringify($.each($(element).children(), function(i,
          // element) {
          // element.attrs();
          // }).get()) + &#x27;. \&quot;&#x27; + x.toString() + &#x27;&quot;&#x27;);
        }
      },

      /**
       * @method processNoteInChord
       */
      processNoteInChord : function(i, element, chordElement, chord) {
        var me = this, atts, xml_id;

        atts = m2v.Util.attsToObj(element);

        var xml_id = atts[&#x27;xml:id&#x27;];
        // If xml:id is missing, create it
        if (!xml_id) {
          xml_id = MeiLib.createPseudoUUID();
          $(element).attr(&#x27;xml:id&#x27;, xml_id);
        }

        if (atts.tie)
          me.processAttrTie(atts.tie, xml_id, atts.pname, atts.oct);
        if (atts.slur)
          me.processAttrSlur(atts.slur, xml_id);

        me.notes_by_id[xml_id] = {
          meiNote : chordElement,
          vexNote : chord,
          index : [i],
          system : me.currentSystem_n
        };

        if (atts.accid) {
          me.processAttrAccid(atts.accid, chord, i);
        }
        if (atts.fermata) {
          me.addFermata(chord, atts.fermata, i);
        }
      },

      /**
       * @method processRest
       */
      processRest : function(element, staff, unused_staff_n) {
        var me = this, dur, rest, xml_id, atts;
        try {
          atts = m2v.Util.attsToObj(element);

          dur = me.processAttsDuration(element, true);
          // assign whole rests to the fourth line, all others to the
          // middle line:
          rest = new VF.StaveNote({
            keys : [(dur === &#x27;w&#x27;) ? &#x27;d/5&#x27; : &#x27;b/4&#x27;],
            duration : dur + &#x27;r&#x27;
          });

          xml_id = atts[&#x27;xml:id&#x27;];

          // If xml:id is missing, create it
          if (!xml_id) {
            xml_id = MeiLib.createPseudoUUID();
            $(element).attr(&#x27;xml:id&#x27;, xml_id);
          }

          if (atts.ho) {
            me.processAttrHo(atts.ho, rest);
          }
          rest.setStave(staff);
          if (atts.dots === &#x27;1&#x27;) {
            rest.addDotToAll();
          }
          if (atts.fermata) {
            me.addFermata(rest, atts.fermata);
          }
          me.notes_by_id[xml_id] = {
            meiNote : element,
            vexNote : rest,
            system : me.currentSystem_n
          };
          return {
            vexNote : rest,
            id : xml_id
          };
        } catch (e) {
          throw new m2v.RUNTIME_ERROR(&#x27;BadArguments&#x27;, &#x27;A problem occurred processing the &lt;rest&gt;: &#x27; + m2v.Util.attsToString(element));
        }
      },

      /**
       * @method processmRest
       */
      processmRest : function(element, staff) {
        var me = this, mRest, atts, xml_id;

        try {
          atts = m2v.Util.attsToObj(element);

          mRest = new VF.StaveNote({
            keys : [&#x27;d/5&#x27;],
            duration : &#x27;wr&#x27;
          });

          xml_id = atts[&#x27;xml:id&#x27;];

          // If xml:id is missing, create it
          if (!xml_id) {
            xml_id = MeiLib.createPseudoUUID();
            $(element).attr(&#x27;xml:id&#x27;, xml_id);
          }

          // mRest.ignore_ticks = true;
          // mRest.addToModifierContext = function() {
          // return this;
          // };
          // console.log(mRest);
          // me.processAttrHo(10, mRest);

          if (atts.ho) {
            me.processAttrHo(atts.ho, mRest);
          }
          if (atts.fermata) {
            me.addFermata(mRest, atts.fermata);
          }
          mRest.setStave(staff);
          me.notes_by_id[xml_id] = {
            meiNote : element,
            vexNote : mRest,
            system : me.currentSystem_n
          };
          return {
            vexNote : mRest,
            id : xml_id
          };
        } catch (x) {
          throw new m2v.RUNTIME_ERROR(&#x27;BadArguments&#x27;, &#x27;A problem occurred processing the &lt;mRest&gt;: &#x27; + m2v.Util.attsToString(element));
        }
      },

      /**
       * @method processSpace
       */
      processSpace : function(element, staff) {
        var me = this, space;
        try {
          space = new VF.GhostNote({
            duration : me.processAttsDuration(element, true) + &#x27;r&#x27;
          });
          // space.setStave(staff);
          // me.notes_by_id[xml_id] = {
          // meiNote : element,
          // vexNote : space
          // };
          return {
            vexNote : space
            // ,
            // id : xml_id
          };
        } catch (e) {
          throw new m2v.RUNTIME_ERROR(&#x27;BadArguments&#x27;, &#x27;A problem occurred processing the &lt;space&gt;: &#x27; + m2v.Util.attsToString(element));
        }
      },

      /**
       * @method processBeam
       */
      processBeam : function(element, staff, staff_n) {
        var me = this, elements;
        var process = function() {
          // make sure to get vexNote out of wrapped note objects
          var proc_element = me.processNoteLikeElement(this, staff, staff_n);
          return proc_element.vexNote || proc_element;
        };
        elements = $(element).children().map(process).get();
        me.allBeams.push(new VF.Beam(elements));
        return elements;
      },

      /**
       * @method processAttrAccid
       */
      processAttrAccid : function(mei_accid, vexObject, i) {
        var val = m2v.tables.accidentals[mei_accid];
        if (!val) {
          throw new m2v.RUNTIME_ERROR(&#x27;MEI2VF.RERR.BadAttributeValue&#x27;, &#x27;Invalid attribute value: &#x27; + mei_accid);
        }
        vexObject.addAccidental(i, new VF.Accidental(val));
      },

      /**
       * @method processAttrHo
       */
      processAttrHo : function(mei_ho, vexObject) {
        var me = this;
        vexObject.setExtraLeftPx(+mei_ho * me.HALF_LINE_DISTANCE);
      },

      /**
       * @method processAttrTie
       */
      processAttrTie : function(mei_tie, xml_id, pname, oct) {
        var me = this, i, j;
        // if (!mei_tie) {
        // mei_tie = &quot;&quot;;
        // }
        for ( i = 0, j = mei_tie.length; i &lt; j; ++i) {
          if (mei_tie[i] === &#x27;i&#x27;) {
            me.ties.start_tieslur(xml_id, {
              pname : pname,
              oct : oct
              //,system : system
            });
          } else if (mei_tie[i] === &#x27;t&#x27;) {
            me.ties.terminate_tie(xml_id, {
              pname : pname,
              oct : oct
              //,system : system
            });
          }
        }
      },

      /**
       * @method processAttrSlur
       */
      processAttrSlur : function(mei_slur, xml_id) {
        var me = this, tokens;
        if (mei_slur) {
          // create a list of { letter, num }
          tokens = me.parse_slur_attribute(mei_slur);
          $.each(tokens, function() {
            if (this.letter === &#x27;i&#x27;) {
              me.slurs.start_tieslur(xml_id, {
                nesting_level : this.nesting_level
                //,system : system
              });
            } else if (this.letter === &#x27;t&#x27;) {
              me.slurs.terminate_slur(xml_id, {
                nesting_level : this.nesting_level
                //,system : system
              });
            }
          });
        }
      },

      /**
       * @method parse_slure_attribute
       */
      parse_slur_attribute : function(slur_str) {
        var result = [], numbered_tokens, numbered_token, i, j, num;
        numbered_tokens = slur_str.split(&#x27; &#x27;);
        for ( i = 0, j = numbered_tokens.length; i &lt; j; i += 1) {
          numbered_token = numbered_tokens[i];
          if (numbered_token.length === 1) {
            result.push({
              letter : numbered_token,
              nesting_level : 0
            });
          } else if (numbered_token.length === 2) {
            num = +numbered_token[1];
            if (!num) {
              throw new m2v.RUNTIME_ERROR(&#x27;MEI2VF.RERR.BadArguments:ParseSlur01&#x27;, &quot;badly formed slur attribute&quot;);
            }
            result.push({
              letter : numbered_token[0],
              nesting_level : num
            });
          } else {
            throw new m2v.RUNTIME_ERROR(&#x27;MEI2VF.RERR.BadArguments:ParseSlur01&#x27;, &quot;badly formed slur attribute&quot;);
          }
        }
        return result;
      },

      /**
       * converts the pitch of an MEI &lt;b&gt;note&lt;/b&gt; element to a VexFlow pitch
       *
       *  @method processAttsPitch
       * @param {XMLElement} mei_note
       * @return {String} the VexFlow pitch
       */
      processAttsPitch : function(mei_note) {
        var pname, oct;
        pname = $(mei_note).attr(&#x27;pname&#x27;);
        oct = $(mei_note).attr(&#x27;oct&#x27;);
        if (!pname || !oct) {
          throw new m2v.RUNTIME_ERROR(&#x27;MEI2VF.RERR.MissingAttribute&#x27;, &#x27;pname and oct attributes must be specified for &lt;note&gt;&#x27;);
        }
        return pname + &#x27;/&#x27; + oct;
      },

      /**
       * adds an articulation to a note-like object
       *  @method addArticulation
       * @param {Vex.Flow.StaveNote} note the note-like VexFlow object
       * @param {XMLElement} ar the articulation element
       */
      addArticulation : function(note, ar) {
        var vexArtic = new VF.Articulation(m2v.tables.articulations[ar.getAttribute(&#x27;artic&#x27;)]);
        var place = ar.getAttribute(&#x27;place&#x27;);
        if (place) {
          vexArtic.setPosition(m2v.tables.positions[place]);
        }
        note.addArticulation(0, vexArtic);
      },

      /**
       * adds a fermata to a note-like object
       *  @method addFermata
       * @param {Vex.Flow.StaveNote} note the note-like VexFlow object
       * @param {&#x27;above&#x27;/&#x27;below&#x27;} place The place of the fermata
       * @param {Number} index The index of the note in a chord (optional)
       */
      addFermata : function(note, place, index) {
        var vexArtic = new VF.Articulation(m2v.tables.fermata[place]);
        vexArtic.setPosition(m2v.tables.positions[place]);
        note.addArticulation(index || 0, vexArtic);
      },

      /**
       * @method processSyllables
       */
      processSyllables : function(note, element, staff_n) {
        var me = this, annot, syl;
        syl = me.processSyllable(element);
        if (syl) {
          annot = me.createAnnot(syl.text, me.cfg.lyricsFont).setVerticalJustification(me.BOTTOM);
          // TODO handle justification
          // .setJustification(VF.Annotation.Justify.LEFT);
          note.addAnnotation(0, annot);
          if (syl.wordpos) {
            me.hyphenation.addSyllable(annot, syl.wordpos, staff_n);
          }
        }
      },

      // Add annotation (lyrics)
      // processSyllable : function(mei_note) {
      // var me = this, syl, full_syl = &#x27;&#x27;, dash;
      // syl = $(mei_note).find(&#x27;syl&#x27;);
      // $(syl).each(function(i, s) {
      // dash = ($(s).attr(&#x27;wordpos&#x27;) === &#x27;i&#x27; || $(s).attr(&#x27;wordpos&#x27;) === &#x27;m&#x27;)
      // ?
      // &#x27;-&#x27; : &#x27;&#x27;;
      // full_syl += (i &gt; 0 ? &#x27;\n&#x27; : &#x27;&#x27;) + $(s).text() + dash;
      // });
      // return full_syl;
      // },

      // temporarily only handle one syllable per note
      /**
       * @method processSyllable
       */
      processSyllable : function(mei_note) {
        var syl = $(mei_note).find(&#x27;syl&#x27;)[0];
        if (syl) {
          return {
            text : $(syl).text(),
            wordpos : $(syl).attr(&#x27;wordpos&#x27;)
          };
        }
      },

      // Support for annotations
      /**
       * @method createAnnot
       */
      createAnnot : function(text, annotFont) {
        return (new VF.Annotation(text)).setFont(annotFont.family, annotFont.size, annotFont.weight);
      },

      /**
       * @method getMandatoryAttr
       */
      getMandatoryAttr : function(element, attribute) {
        var result = $(element).attr(attribute);
        if (!result) {
          throw new m2v.RUNTIME_ERROR(&#x27;MEI2VF.RERR.MissingAttribute&#x27;, &#x27;Attribute &#x27; + attribute + &#x27; is mandatory.&#x27;);
        }
        return result;
      },

      /**
       * @method translateDuration
       */
      translateDuration : function(mei_dur) {
        var result = m2v.tables.durations[mei_dur + &#x27;&#x27;];
        if (result)
          return result;
        throw new m2v.RUNTIME_ERROR(&#x27;BadArguments&#x27;, &#x27;The MEI duration &quot;&#x27; + mei_dur + &#x27;&quot; is not supported.&#x27;);
      },

      // TODO: dots should work with the lastest VexFlow, so try to remove the noDots
      // parameter there. Can the noDots condition be removed entirely or will there
      // be dots rendered with space elements?
      /**
       * @method processAttsDuration
       */
      processAttsDuration : function(mei_note, noDots) {
        var me = this, dur, dur_attr;

        dur_attr = $(mei_note).attr(&#x27;dur&#x27;);
        if (dur_attr === undefined) {
          alert(&#x27;Could not get duration from:\n&#x27; + JSON.stringify(mei_note, null, &#x27;\t&#x27;));
        }
        dur = me.translateDuration(dur_attr);
        if (!noDots &amp;&amp; $(mei_note).attr(&#x27;dots&#x27;) === &#x27;1&#x27;)
          dur += &#x27;d&#x27;;
        return dur;
      },

      /**
       * @method setStemDir
       */
      setStemDir : function(element, optionsObj) {
        var specified_dir = {
        down : VF.StaveNote.STEM_DOWN,
        up : VF.StaveNote.STEM_UP
        }[$(element).attr(&#x27;stem.dir&#x27;)];
        if (specified_dir) {
          optionsObj.stem_direction = specified_dir;
        } else {
          optionsObj.auto_stem = true;
        }
      },

      /**
       * @method drawSystems
       */
      drawSystems : function(ctx) {
        var me = this, i = me.systems.length;
        while (i--) {
          if (me.systems[i]) {
            me.systems[i].format(ctx).draw(ctx);
          }
        }
      },

      /**
       * @method drawVexBeams
       */
      drawVexBeams : function(beams, ctx) {
        $.each(beams, function() {
          this.setContext(ctx).draw();
        });

      }
    };

    return m2v;

  }(MEI2VF || {}, Vex.Flow, jQuery));

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
